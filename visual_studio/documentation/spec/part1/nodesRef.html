<html>
<head>
  <meta NAME="GENERATOR" CONTENT="Adobe PageMill 2.0 Win">
  <title>VRML97, ISO/IEC 14772-1:1997 -- 6 Node Reference</title>
</head>
<body>

<p><center><img SRC="../Images/vrml97.gif" ALIGN="TOP" WIDTH="470" HEIGHT="85" NATURALSIZEFLAG="0" ALT="VRML97 logo"></center></p>

<h1><center>The Virtual Reality Modeling Language</center></h1>

<h1><center>6 Node reference</center></h1>

<h2><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></h2>

<h2><a NAME="6.1"></a><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"> 6.1 Introduction</h2>

<p>This clause provides a detailed definition of the syntax and semantics
of each node in this part of ISO/IEC 14772. <a HREF="nodesref.html#Table6.1">Table 6.1</a>
lists the topics in this clause.</p>

<h4><center><a NAME="Table6.1"></a>Table 6.1 -- Table of contents</center></h4>

<p><table BORDER="2" CELLPADDING="8" CELLSPACING="4">
<tr>
<td WIDTH="30%" VALIGN="TOP"><a HREF="nodesref.html#6.1">6.1 Introduction</a><br>
<a HREF="nodesref.html#Anchor">6.2 Anchor</a> <br>
<a HREF="nodesref.html#Appearance">6.3 Appearance</a> <br>
<a HREF="nodesref.html#AudioClip">6.4 AudioClip</a> <br>
<a HREF="nodesref.html#Background">6.5 Background</a><br>
<a HREF="nodesref.html#Billboard">6.6 Billboard</a> <br>
<a HREF="nodesref.html#Box">6.7 Box</a> <br>
<a HREF="nodesref.html#Collision">6.8 Collision</a> <br>
<a HREF="nodesref.html#Color">6.9 Color</a> <br>
<a HREF="nodesref.html#ColorInterpolator">6.10 ColorInterpolator</a> <br>
<a HREF="nodesref.html#Cone">6.11 Cone</a> <br>
<a HREF="nodesref.html#Coordinate">6.12 Coordinate</a> <br>
<a HREF="nodesref.html#CoordinateInterpolator">6.13&nbsp;CoordinateInterpolator</a><br>
<a HREF="nodesref.html#Cylinder">6.14 Cylinder</a> <br>
<a HREF="nodesref.html#CylinderSensor">6.15 CylinderSensor</a> <br>
<a HREF="nodesref.html#DirectionalLight">6.16 DirectionalLight</a> <br>
<a HREF="nodesref.html#ElevationGrid">6.17 ElevationGrid</a> <br>
<a HREF="nodesref.html#Extrusion">6.18 Extrusion</a> <br>
<a HREF="nodesref.html#Fog">6.19 Fog</a></td>
<td WIDTH="30%" VALIGN="TOP"><a HREF="nodesref.html#FontStyle">6.20 FontStyle</a> <br>
<a HREF="nodesref.html#Group">6.21 Group</a> <br>
<a HREF="nodesref.html#ImageTexture">6.22 ImageTexture</a> <br>
<a HREF="nodesref.html#IndexedFaceSet">6.23 IndexedFaceSet</a> <br>
<a HREF="nodesref.html#IndexedLineSet">6.24 IndexedLineSet</a> <br>
<a HREF="nodesref.html#Inline">6.25 Inline</a> <br>
<a HREF="nodesref.html#LOD">6.26 LOD</a> <br>
<a HREF="nodesref.html#Material">6.27 Material</a> <br>
<a HREF="nodesref.html#MovieTexture">6.28 MovieTexture</a> <br>
<a HREF="nodesref.html#NavigationInfo">6.29 NavigationInfo</a> <br>
<a HREF="nodesref.html#Normal">6.30 Normal</a> <br>
<a HREF="nodesref.html#NormalInterpolator">6.31 NormalInterpolator</a> <br>
<a HREF="nodesref.html#OrientationInterpolator">6.32&nbsp;OrientationInterpolator</a><br>
<a HREF="nodesref.html#PixelTexture">6.33 PixelTexture</a> <br>
<a HREF="nodesref.html#PlaneSensor">6.34 PlaneSensor</a> <br>
<a HREF="nodesref.html#PointLight">6.35 PointLight</a> <br>
<a HREF="nodesref.html#PointSet">6.36 PointSet</a> <br>
<a HREF="nodesref.html#PositionInterpolator">6.37 PositionInterpolator</a> <br>
<a HREF="nodesref.html#ProximitySensor">6.38 ProximitySensor</a></td>
<td WIDTH="30%" VALIGN="TOP"><a HREF="nodesref.html#ScalarInterpolator">6.39 ScalarInterpolator</a> <br>
<a HREF="nodesref.html#Script">6.40 Script</a> <br>
<a HREF="nodesref.html#Shape">6.41 Shape</a> <br>
<a HREF="nodesref.html#Sound">6.42 Sound</a> <br>
<a HREF="nodesref.html#Sphere">6.43 Sphere</a> <br>
<a HREF="nodesref.html#SphereSensor">6.44 SphereSensor</a> <br>
<a HREF="nodesref.html#SpotLight">6.45 SpotLight</a> <br>
<a HREF="nodesref.html#Switch">6.46 Switch</a> <br>
<a HREF="nodesref.html#Text">6.47 Text</a> <br>
<a HREF="nodesref.html#TextureCoordinate">6.48 TextureCoordinate</a> <br>
<a HREF="nodesref.html#TextureTransform">6.49 TextureTransform</a> <br>
<a HREF="nodesref.html#TimeSensor">6.50 TimeSensor</a> <br>
<a HREF="nodesref.html#TouchSensor">6.51 TouchSensor</a> <br>
<a HREF="nodesref.html#Transform">6.52 Transform</a> <br>
<a HREF="nodesref.html#Viewpoint">6.53 Viewpoint</a> <br>
<a HREF="nodesref.html#VisibilitySensor">6.54 VisibilitySensor</a> <br>
<a HREF="nodesref.html#WorldInfo">6.55 WorldInfo</a></td></tr>
</table>
</p>

<p>In this clause, the first item in each subclause presents the public
declaration for the node. This syntax is not the actual UTF-8 encoding syntax.
The parts of the interface that are identical to the UTF-8 encoding syntax
are in <b>bold</b>. The node declaration defines the names and types of
the fields and events for the node, as well as the default values for the
fields.</p>

<p>The node declarations also include value ranges for the node's fields
and exposedFields (where appropriate). Parentheses imply that the range
bound is exclusive, while brackets imply that the range value is inclusive.
For example, a range of (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,1] defines the lower bound as -<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3"> exclusively and the upper bound
as 1 inclusively.</p>

<p>For example, the following defines the Collision node declaration:</p>

<pre>
<b>   Collision {</b> 
      eventIn      MFNode   addChildren
      eventIn      MFNode   removeChildren
<b>     </b> exposedField MFNode   <b>children    []</b>
      exposedField SFBool   <b>collide     TRUE</b>
      field        SFVec3f  <b>bboxCenter  0 0 0</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
      field        SFVec3f  <b>bboxSize    -1 -1 -1</b>  # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">) or -1,-1,-1
      field        SFNode   <b>proxy       NULL</b>
      eventOut     SFTime   collideTime
<b>    }</b></pre>

<p>The fields and events contained within the node declarations are ordered
as follows:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>eventIns, in alphabetical order;
  <li>exposedFields, in alphabetical order;
  <li>fields, in alphabetical order;
  <li>eventOuts, in alphabetical order.
</ol><!--/NOEDIT--></p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Anchor"></a>6.2 Anchor</h2>

<pre>
<b>Anchor { </b>
  eventIn      MFNode   addChildren
  eventIn      MFNode   removeChildren
  exposedField MFNode   <b>children        []</b>
  exposedField SFString <b>description     &quot;&quot; </b>
  exposedField MFString <b>parameter       []</b>
  exposedField MFString <b>url             []</b>
  field        SFVec3f  <b>bboxCenter      0 0 0</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f  <b>bboxSize        -1 -1 -1</b>  # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">) or -1,-1,-1
<b>}</b></pre>

<p>The Anchor grouping node retrieves the content of a URL when the user
activates (e.g.,&nbsp;clicks) some geometry contained within the Anchor
node's children. If the URL points to a valid VRML file, that world replaces
the world of which the Anchor node is a part (except when the <i>parameter</i>
field, described below, alters this behaviour). If non-VRML data is retrieved,
the browser shall determine how to handle that data; typically, it will
be passed to an appropriate non-VRML browser.</p>

<p>Exactly how a user activates geometry contained by the Anchor node depends
on the pointing device and is determined by the VRML browser. Typically,
clicking with the pointing device will result in the new scene replacing
the current scene. An Anchor node with an empty <i>url</i> does nothing
when its children are chosen. A description of how multiple Anchors and
pointing-device sensors are resolved on activation is contained in <a HREF="concepts.html#4.6.7">4.6.7,&nbsp;Sensor nodes</a>.</p>

<p>More details on the <i>children</i>, <i>addChildren</i>, and <i>removeChildren</i>
fields and eventIns can be found in <a HREF="concepts.html#4.6.5">4.6.5,
Grouping and children nodes</a>.</p>

<p>The <i>description</i> field in the Anchor node specifies a textual description
of the Anchor node. This may be used by browser-specific user interfaces
that wish to present users with more detailed information about the Anchor.</p>

<p>The <i>parameter</i> exposed field may be used to supply any additional
information to be interpreted by the browser. Each string shall consist
of &quot;keyword=value&quot; pairs. For example, some browsers allow the
specification of a 'target' for a link to display a link in another part
of an HTML document. The <i>parameter</i> field is then:</p>

<pre>
<b>Anchor { </b>
<b>  parameter [ &quot;target=name_of_frame&quot; ]</b>
  ...
<b>}</b></pre>

<p>An Anchor node may be used to bind the initial <a HREF="nodesref.html#Viewpoint">Viewpoint</a>
node in a world by specifying a URL ending with &quot;#ViewpointName&quot;
where &quot;ViewpointName&quot; is the name of a viewpoint defined in the
VRML file. For example:</p>

<pre>
<b>Anchor { </b>
<b>  url &quot;http://www.school.edu/vrml/someScene.wrl#OverView&quot;</b>
<b>  children  Shape { geometry Box {} }</b>
<b>}</b></pre>

<p>specifies an anchor that loads the VRML file &quot;someScene.wrl&quot;
and binds the initial user view to the Viewpoint node named &quot;OverView&quot;
when the Anchor node's geometry (Box) is activated. If the named Viewpoint
node is not found in the VRML file, the VRML file is loaded using the default
Viewpoint node binding stack rules (see <a HREF="nodesref.html#Viewpoint">6.53, Viewpoint</a>).</p>

<p>If the <i>url</i> field is specified in the form &quot;#ViewpointName&quot;
(i.e.&nbsp;no file name), the Viewpoint node with the given name (&quot;ViewpointName&quot;)
in the Anchor's run-time name scope(s) shall be bound (<i>set_bind </i>TRUE).
The results are undefined if there are multiple Viewpoints with the same
name in the Anchor's run-time name scope(s). The results are undefined if
the Anchor node is not part of any run-time name scope or is part of more
than one run-time name scope. See <a HREF="concepts.html#4.4.6">4.4.6,&nbsp;Run-time&nbsp;name&nbsp;scope</a>,
for a description of run-time name scopes. See <a HREF="nodesref.html#Viewpoint">6.53,&nbsp;Viewpoint</a>,
for the Viewpoint transition rules that specify how browsers shall interpret
the transition from the old Viewpoint node to the new one. For example:</p>

<pre>
<b><tt>Anchor { </tt></b>
<b><tt>  url &quot;#Doorway&quot;</tt></b>
<b><tt>  children Shape { geometry Sphere {} }</tt></b>
<b><tt>}</tt></b></pre>

<p>binds the viewer to the viewpoint defined by the &quot;Doorway&quot;
viewpoint in the current world when the sphere is activated. In this case,
if the Viewpoint is not found, no action occurs on activation.</p>

<p>More details on the <i>url</i> field are contained in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the Anchor's children. This is a hint that may be used for
optimization purposes. The results are undefined if the specified bounding
box is smaller than the actual bounding box of the children at any time.
The default <i>bboxSize</i> value, (-1,&nbsp;-1,&nbsp;-1), implies that
the bounding box is not specified and if needed shall be calculated by the
browser. More details on the <i>bboxCenter</i> and <i>bboxSize</i> fields
can be found in <a HREF="concepts.html#4.6.4">4.6.4, Bounding boxes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Appearance"></a>6.3 Appearance</h2>

<pre>
<b>Appearance { </b>
  exposedField SFNode <b>material          NULL</b>
  exposedField SFNode<b> texture           NULL</b>
  exposedField SFNode <b>textureTransform  NULL</b>
<b>}</b></pre>

<p>The Appearance node specifies the visual properties of geometry. The
value for each of the fields in this node may be NULL. However, if the field
is non-NULL, it shall contain one node of the appropriate type.</p>

<p>The <i>material</i> field, if specified, shall contain a <a HREF="nodesref.html#Material">Material</a>
node. If the <i>material</i> field is NULL or unspecified, lighting is off
(all lights are ignored during rendering of the object that references this
Appearance) and the unlit object colour is (1,&nbsp;1,&nbsp;1). Details
of the VRML lighting model are in <a HREF="concepts.html#4.14">4.14, Lighting
model</a>.</p>

<p>The <i>texture</i> field, if specified, shall contain one of the various
types of texture nodes (<a HREF="nodesref.html#ImageTexture">ImageTexture</a>, <a HREF="nodesref.html#MovieTexture">MovieTexture</a>, or <a HREF="nodesref.html#PixelTexture">PixelTexture</a>).
If the texture node is NULL or the <i>texture</i> field is unspecified,
the object that references this Appearance is not textured.</p>

<p>The <i>textureTransform</i> field, if specified, shall contain a <a HREF="nodesref.html#TextureTransform">TextureTransform</a> node. If the <i>textureTransform</i>
is NULL or unspecified, the <i>textureTransform</i> field has no effect.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="AudioClip"></a>6.4 AudioClip</h2>

<pre>
<b>AudioClip { </b>
  exposedField   SFString <b>description      &quot;&quot;</b>
  exposedField   SFBool   <b>loop             FALSE</b>
  exposedField   SFFloat  <b>pitch            1.0        </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField   SFTime   <b>startTime        0          </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField   SFTime   <b>stopTime         0          </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField   MFString <b>url              []</b>
  eventOut       SFTime   duration_changed
  eventOut       SFBool   isActive
<b>}</b></pre>

<p>An AudioClip node specifies audio data that can be referenced by <a HREF="nodesref.html#Sound">Sound</a> nodes.</p>

<p>The <i>description</i> field specifies a textual description of the audio
source. A browser is not required to display the <i>description</i> field
but may choose to do so in addition to playing the sound.</p>

<p>The <i>url</i> field specifies the URL from which the sound is loaded.
Browsers shall support at least the <i>wavefile</i> format in uncompressed
PCM format (see <a HREF="bibliography.html#[WAV]">E.[WAV]</a>). It is recommended
that browsers also support the MIDI file type 1 sound format (see <a HREF="references.html#[MIDI]">2.[MIDI]</a>); MIDI files are presumed to use the
General MIDI patch set. Subclause <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>,
contains details on the <i>url</i> field. The results are undefined when
no URLs refer to supported data types</p>

<p>The <i>loop, startTime,</i> and <i>stopTime</i> exposedFields and the
<i>isActive</i> eventOut, and their effects on the AudioClip node, are discussed
in detail in <a HREF="concepts.html#4.6.9">4.6.9,&nbsp;Time-dependent nodes</a>.
The &quot;<i>cycle&quot;</i> of an AudioClip is the length of time in seconds
for one playing of the audio at the specified <i>pitch</i>.</p>

<p>The <i>pitch</i> field specifies a multiplier for the rate at which sampled
sound is played. Values for the <i>pitch</i> field shall be greater than
zero<i>.</i> Changing the <i>pitch</i> field affects both the pitch and
playback speed of a sound. A <i>set_pitch</i> event to an active AudioClip
is ignored and no <i>pitch_changed</i> eventOut is generated. If <i>pitch</i>
is set to 2.0, the sound shall be played one octave higher than normal and
played twice as fast. For a sampled sound, the <i>pitch</i> field alters
the sampling rate at which the sound is played. The proper implementation
of pitch control for MIDI (or other note sequence sound clips) is to multiply
the tempo of the playback by the <i>pitch</i> value and adjust the MIDI
Coarse Tune and Fine Tune controls to achieve the proper pitch change.</p>

<p>A <i>duration_changed</i> event is sent whenever there is a new value
for the &quot;normal&quot; duration of the clip. Typically, this will only
occur when the current <i>url</i> in use changes and the sound data has
been loaded, indicating that the clip is playing a different sound source.
The duration is the length of time in seconds for one cycle of the audio
for a <i>pitch</i> set to 1.0. Changing the <i>pitch</i> field will not
trigger a <i>duration_changed</i> event. A duration value of &quot;-1&quot;
implies that the sound data has not yet loaded or the value is unavailable
for some reason. A <i>duration_changed</i> event shall be generated if the
AudioClip node is loaded when the VRML file is read or the AudioClip node
is added to the scene graph.</p>

<p>The <i>isActive</i> eventOut may be used by other nodes to determine
if the clip is currently active. If an AudioClip is active, it shall be
playing the sound corresponding to the sound time (i.e.,&nbsp;in the sound's
local time system with sample 0 at time 0):</p>

<pre>
    t = (now - startTime) modulo (<tt>duration</tt> / pitch)</pre>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Background"></a>6.5 Background</h2>

<pre>
<b>Background { </b>
  eventIn      SFBool   set_bind
  exposedField MFFloat  <b>groundAngle  []         </b># [0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2]
  exposedField MFColor<b>  groundColor  []         </b># [0,1]
  exposedField MFString <b>backUrl      []</b>
  exposedField MFString <b>bottomUrl    []</b>
  exposedField MFString <b>frontUrl     []</b>
  exposedField MFString <b>leftUrl      []</b>
  exposedField MFString <b>rightUrl     []</b>
  exposedField MFString <b>topUrl       []</b>
  exposedField MFFloat  <b>skyAngle     []         </b># [0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">]
  exposedField MFColor  <b>skyColor     0 0 0      </b># [0,1]
  eventOut     SFBool   isBound
<b>}</b></pre>

<p>The Background node is used to specify a colour backdrop that simulates
ground and sky, as well as a background texture, or <i>panorama</i>, that
is placed behind all geometry in the scene and in front of the ground and
sky. Background nodes are specified in the local coordinate system and are
affected by the accumulated rotation of their ancestors as described below.</p>

<p>Background nodes are bindable nodes as described in <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable
children nodes</a>. There exists a Background stack, in which the top-most
Background on the stack is the currently active Background. To move a Background
to the top of the stack, a TRUE value is sent to the <i>set_bind</i> eventIn.
Once active, the Background is then bound to the browsers view. A FALSE
value sent to <i>set_bind</i> removes the Background from the stack and
unbinds it from the browser's view. More detail on the bind stack is described
in <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable children nodes</a>.</p>

<p>The backdrop is conceptually a partial sphere (the ground) enclosed inside
of a full sphere (the sky) in the local coordinate system with the viewer
placed at the centre of the spheres. Both spheres have infinite radius and
each is painted with concentric circles of interpolated colour perpendicular
to the local Y-axis of the sphere. The Background node is subject to the
accumulated rotations of its ancestors' transformations. Scaling and translation
transformations are ignored. The sky sphere is always slightly farther away
from the viewer than the ground partial sphere causing the ground to appear
in front of the sky where they overlap.</p>

<p>The <i>skyColor</i> field specifies the colour of the sky at various
angles on the sky sphere. The first value of the <i>skyColor</i> field specifies
the colour of the sky at 0.0 radians representing the zenith (i.e.,&nbsp;straight
up from the viewer). The <i>skyAngle</i> field specifies the angles from
the zenith in which concentric circles of colour appear. The zenith of the
sphere is implicitly defined to be 0.0 radians, the natural horizon is at
<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2 radians, and the nadir (i.e.,
straight down from the viewer) is at <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3"> radians. <i>skyAngle</i> is restricted
to non-decreasing values in the range [0.0, <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">]. There shall be one more <i>skyColor</i>
value than there are <i>skyAngle</i> values. The first colour value is the
colour at the zenith, which is not specified in the <i>skyAngle</i> field.
If the last <i>skyAngle</i> is less than <i>pi</i>, then the colour band
between the last <i>skyAngle</i> and the nadir is clamped to the last <i>skyColor</i>.
The sky colour is linearly interpolated between the specified <i>skyColor
</i>values.</p>

<p>The <i>groundColor</i> field specifies the colour of the ground at the
various angles on the ground partial sphere. The first value of the <i>groundColor</i>
field specifies the colour of the ground at 0.0 radians representing the
nadir (i.e.,&nbsp;straight down from the user). The <i>groundAngle</i> field
specifies the angles from the nadir that the concentric circles of colour
appear. The nadir of the sphere is implicitly defined at 0.0 radians. <i>groundAngle</i>
is restricted to non-decreasing values in the range [0.0, <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2]. There shall be one more <i>groundColor</i>
value than there are <i>groundAngle</i> values. The first colour value is
for the nadir which is not specified in the <i>groundAngle</i> field. If
the last <i>groundAngle</i> is less than <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2, the region between the last <i>groundAngle</i>
and the equator is non-existant. The ground colour is linearly interpolated
between the specified <i>groundColor </i>values.</p>

<p>The <i>backUrl</i>, <i>bottomUrl</i>, <i>frontUrl</i>, <i>leftUrl</i>,
<i>rightUrl</i>, and <i>topUrl</i> fields specify a set of images that define
a background panorama between the ground/sky backdrop and the scene's geometry.
The panorama consists of six images, each of which is mapped onto a face
of an infinitely large cube contained within the backdrop spheres and centred
in the local coordinate system. The images are applied individually to each
face of the cube. On the front, back, right, and left faces of the cube,
when viewed from the origin looking down the negative Z-axis with the Y-axis
as the view up direction, each image is mapped onto the corresponding face
with the same orientation as if the image were displayed normally in 2D
(<i>backUrl</i> to back face, <i>frontUrl</i> to front face, <i>leftUrl</i>
to left face, and <i>rightUrl</i> to right face<i>)</i>. On the top face
of the cube, when viewed from the origin looking along the +Y-axis with
the +Z-axis as the view up direction, the <i>topUrl</i> image is mapped
onto the face with the same orientation as if the image were displayed normally
in 2D. On the bottom face of the box, when viewed from the origin along
the negative Y-axis with the negative Z-axis as the view up direction, the
<i>bottomUrl</i> image is mapped onto the face with the same orientation
as if the image were displayed normally in 2D.</p>

<p><a HREF="nodesref.html#Figure6.1">Figure 6.1</a> illustrates the Background node backdrop
and background textures.</p>

<p>Alpha values in the panorama images (i.e.,&nbsp;two or four component
images) specify that the panorama is semi-transparent or transparent in
regions, allowing the <i>groundColor</i> and <i>skyColor</i> to be visible.</p>

<p>See <a HREF="concepts.html#4.6.11">4.6.11, Texture maps</a>, for a general
description of texture maps.</p>

<p>Often, the <i>bottomUrl</i> and <i>topUrl</i> images will not be specified,
to allow sky and ground to show. The other four images may depict surrounding
mountains or other distant scenery. Browsers shall support the JPEG (see
<a HREF="references.html#[JPEG]">2.[JPEG]</a>) and PNG (see <a HREF="references.html#[PNG]">2.[PNG]</a>)
image file formats, and in addition, may support any other image format
(e.g., CGM) that can be rendered into a 2D image. Support for the GIF (see
<a HREF="bibliography.html#[GIF]">E.[GIF]</a>) format is recommended (including
transparency) . More detail on the <i>url</i> fields can be found in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p><a NAME="Figure6.1"></a><img SRC="../Images/background.gif" WIDTH="615" HEIGHT="312" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/background.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Background node"></p>

<h4><center>Figure 6.1 -- Background node</center></h4>

<p>Panorama images may be one component (greyscale), two component (greyscale
plus alpha), three component (full RGB colour), or four-component (full
RGB colour plus alpha).</p>

<p>Ground colours, sky colours, and panoramic images do not translate with
respect to the viewer, though they do rotate with respect to the viewer.
That is, the viewer can never get any closer to the background, but can
turn to examine all sides of the panorama cube, and can look up and down
to see the concentric rings of ground and sky (if visible).</p>

<p>Background nodes are not affected by <a HREF="nodesref.html#Fog">Fog</a> nodes. Therefore,
if a Background node is active (i.e.,&nbsp;bound) while a Fog node is active,
then the Background node will be displayed with no fogging effects. It is
the author's responsibility to set the Background values to match the Fog
values (e.g.,&nbsp;ground colours fade to fog colour with distance and panorama
images tinted with fog colour). Background nodes are not affected by light
sources.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Billboard"></a>6.6 Billboard</h2>

<pre>
<b>Billboard { </b>
  eventIn      MFNode   addChildren
  eventIn      MFNode   removeChildren
  exposedField SFVec3f  <b>axisOfRotation 0 1 0     </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFNode   <b>children       []</b>
  field        SFVec3f  <b>bboxCenter     0 0 0     </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f  <b>bboxSize       -1 -1 -1 </b> #&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">) or -1,-1,-1
<b>}</b></pre>

<p>The Billboard node is a grouping node which modifies its coordinate system
so that the Billboard node's local Z-axis turns to point at the viewer.
The Billboard node has children which may be other children nodes.</p>

<p>The <i>axisOfRotation</i> field specifies which axis to use to perform
the rotation. This axis is defined in the local coordinate system.</p>

<p>When the <i>axisOfRotation</i> field is not (0,&nbsp;0,&nbsp;0), the
following steps describe how to rotate the billboard to face the viewer:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>Compute the vector from the Billboard node's origin to the viewer's
  position. This vector is called the <i>billboard-to-viewer</i> vector.
  <li>Compute the plane defined by the <i>axisOfRotation</i> and the billboard-to-viewer
  vector.
  <li>Rotate the local Z-axis of the billboard into the plane from b., pivoting
  around the <i>axisOfRotation</i>.
</ol><!--/NOEDIT--></p>

<p>When the axisOfRotation field is set to (0,&nbsp;0,&nbsp;0), the special
case of <i>viewer-alignment</i> is indicated. In this case, the object rotates
to keep the billboard's local Y-axis parallel with the Y-axis of the viewer.
This special case is distinguished by setting the <i>axisOfRotation</i>
to (0, 0, 0). The following steps describe how to align the billboard's
Y-axis to the Y-axis of the viewer:</p>

<p><!--NOEDIT--><ol START="4" TYPE="a">
  <li>Compute the billboard-to-viewer<i> </i>vector.
  <li>Rotate the Z-axis of the billboard to be collinear with the billboard-to-viewer
  vector and pointing towards the viewer's position.
  <li>Rotate the Y-axis of the billboard to be parallel and oriented in the
  same direction as the Y-axis of the viewer.
</ol><!--/NOEDIT--></p>

<p>If the <i>axisOfRotation</i> and the billboard-to-viewer line are coincident,
the plane cannot be established and the resulting rotation of the billboard
is undefined. For example, if the <i>axisOfRotation</i> is set to (0,1,0)
(Y-axis) and the viewer flies over the billboard and peers directly down
the Y-axis, the results are undefined<b>.</b></p>

<p>Multiple instances of Billboard nodes (DEF/USE) operate as expected:
each instance rotates in its unique coordinate system to face the viewer.</p>

<p>Subclause <a HREF="concepts.html#4.6.5">4.6.5, Grouping and children
node<i>s</i></a>, provides a description of the <i>children</i>, <i>addChildren</i>,
and <i>removeChildren</i> fields and eventIns.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the Billboard node's children. This is a hint that may be
used for optimization purposes. The results are undefined if the specified
bounding box is smaller than the actual bounding box of the children at
any time. A default <i>bboxSize</i> value, (-1,&nbsp;-1,&nbsp;-1), implies
that the bounding box is not specified and if needed shall be calculated
by the browser. A description of the <i>bboxCenter</i> and <i>bboxSize</i>
fields is contained in <a HREF="concepts.html#4.6.4">4.6.4, Bounding boxes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Box"></a>6.7 Box</h2>

<pre>
<b>Box { </b>
  field    SFVec3f <b>size  2 2 2 </b>       #&nbsp;(0,&nbsp;<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The Box node specifies a rectangular parallelepiped box centred at (0,&nbsp;0,&nbsp;0)
in the local coordinate system and aligned with the local coordinate axes.
By default, the box measures 2 units in each dimension, from -1 to +1. The
<i>size</i> field specifies the extents of the box along the X-, Y-, and
Z-axes respectively and each component value shall be greater than zero.
<a HREF="nodesref.html#Figure6.2">Figure 6.2</a> illustrates the Box node.</p>

<p><center><a NAME="Figure6.2"></a><img SRC="../Images/box.gif" WIDTH="353" HEIGHT="326" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/box.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Box node"></center></p>

<h4><center>Figure 6.2 -- Box node</center></h4>

<p>Textures are applied individually to each face of the box. On the front
(+Z), back (-Z), right (+X), and left (-X) faces of the box, when viewed
from the outside with the +Y-axis up, the texture is mapped onto each face
with the same orientation as if the image were displayed normally in 2D.
On the top face of the box (+Y), when viewed from above and looking down
the Y-axis toward the origin with the -Z-axis as the view up direction,
the texture is mapped onto the face with the same orientation as if the
image were displayed normally in 2D. On the bottom face of the box (-Y),
when viewed from below looking up the Y-axis toward the origin with the
+Z-axis as the view up direction, the texture is mapped onto the face with
the same orientation as if the image were displayed normally in 2D. <a HREF="nodesref.html#TextureTransform">TextureTransform</a> affects the texture coordinates
of the Box.</p>

<p>The Box node's geometry requires outside faces only. When viewed from
the inside the results are undefined.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Collision"></a>6.8 Collision</h2>

<pre>
<b>Collision {</b> 
  eventIn      MFNode   addChildren
  eventIn      MFNode   removeChildren
<b> </b> exposedField MFNode   <b>children        []</b>
  exposedField SFBool   <b>collide         TRUE</b>
  field        SFVec3f  <b>bboxCenter      0 0 0</b>      # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f  <b>bboxSize        -1 -1 -1</b>   # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">) or -1,-1,-1
  field        SFNode   <b>proxy           NULL</b>
  eventOut     SFTime   collideTime
<b>}</b></pre>

<p>The Collision node is a grouping node that specifies the collision detection
properties for its children (and their descendants), specifies surrogate
objects that replace its children during collision detection, and sends
events signalling that a collision has occurred between the avatar and the
Collision node's geometry or surrogate. By default, all geometric nodes
in the scene are collidable with the viewer except IndexedLineSet, PointSet,
and Text. Browsers shall detect geometric collisions between the avatar
(see <a HREF="nodesref.html#NavigationInfo">6.29,&nbsp;NavigationInfo</a>) and the scene's
geometry and prevent the avatar from 'entering' the geometry. See <a HREF="concepts.html#4.13.4">4.13.4,&nbsp;Collision&nbsp;detection&nbsp;and&nbsp;terrain&nbsp;following</a>,
for general information on collision detection.</p>

<p>If there are no Collision nodes specified in a VRML file, browsers shall
detect collisions between the avatar and all objects during navigation.</p>

<p>Subclause <a HREF="concepts.html#4.6.5">4.6.5, Grouping and children
nodes</a>, contains a description of the <i>children</i>, <i>addChildren</i>,
and <i>removeChildren</i> fields and eventIns.</p>

<p>The Collision node's <i>collide</i> field enables and disables collision
detection. If <i>collide</i> is set to FALSE, the children and all descendants
of the Collision node shall not be checked for collision, even though they
are drawn. This includes any descendent Collision nodes that have <i>collide</i>
set to TRUE (i.e.,&nbsp;setting <i>collide</i> to FALSE turns collision
off for every node below it).</p>

<p>Collision nodes with the <i>collide</i> field set to TRUE detect the
nearest collision with their descendent geometry (or proxies). When the
nearest collision is detected, the collided Collision node sends the time
of the collision through its <i>collideTime</i> eventOut. If a Collision
node contains a child, descendant, or proxy (see below) that is a Collision
node, and both Collision nodes detect that a collision has occurred, both
send a <i>collideTime</i> event at the same time. A <i>collideTime</i> event
shall be generated if the avatar is colliding with collidable geometry when
the Collision node is read from a VRML file or inserted into the transformation
hierarchy.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the Collision node's children. This is a hint that may be
used for optimization purposes. The results are undefined if the specified
bounding box is smaller than the actual bounding box of the children at
any time. A default <i>bboxSize</i> value, (-1,&nbsp;-1,&nbsp;-1), implies
that the bounding box is not specified and if needed shall be calculated
by the browser. More details on the <i>bboxCenter</i> and <i>bboxSize</i>
fields can be found in <a HREF="concepts.html#4.6.4">4.6.4, Bounding boxes</a>.</p>

<p>The collision proxy, defined in the <i>proxy</i> field, is any legal
children node as described in <a HREF="concepts.html#4.6.5">4.6.5,&nbsp;Grouping
and children nodes</a>, that is used as a substitute for the Collision node's
children during collision detection. The proxy is used strictly for collision
detection; it is not drawn.</p>

<p>If the value of the <i>collide</i> field is TRUE and the <i>proxy</i>
field is non-NULL, the <i>proxy</i> field defines the scene on which collision
detection is performed. If the <i>proxy</i> value is NULL, collision detection
is performed against the <i>children</i> of the Collision node.</p>

<p>If <i>proxy</i> is specified, any descendent children of the Collision
node are ignored during collision detection. If <i>children</i> is empty,
<i>collide</i> is TRUE, and <i>proxy</i> is specified, collision detection
is performed against the proxy but nothing is displayed. In this manner,
invisible collision objects may be supported.</p>

<p>The <i>collideTime</i> eventOut generates an event specifying the time
when the avatar (see&nbsp;<a HREF="nodesref.html#NavigationInfo">6.29,&nbsp;NavigationInfo</a>)
makes contact with the collidable children or proxy of the Collision node.
An ideal implementation computes the exact time of collision. Implementations
may approximate the ideal by sampling the positions of collidable objects
and the user. The <a HREF="nodesref.html#NavigationInfo">NavigationInfo</a> node contains
additional information for parameters that control the avatar size.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Color"></a>6.9 Color</h2>

<pre>
<b>Color { </b>
  exposedField MFColor <b>color  []         </b># [0,1]
<b>}</b></pre>

<p>This node defines a set of RGB colours to be used in the fields of another
node.</p>

<p>Color nodes are only used to specify multiple colours for a single geometric
shape, such as colours for the faces or vertices of an IndexedFaceSet. A
Material node is used to specify the overall material parameters of lit
geometry. If both a Material node and a Color node are specified for a geometric
shape, the colours shall replace the diffuse component of the material.</p>

<p>RGB or RGBA textures take precedence over colours; specifying both an
RGB or RGBA texture and a Color node for geometric shape will result in
the Color node being ignored. Details on lighting equations can be found
in <a HREF="concepts.html#4.14">4.14, Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="ColorInterpolator"></a> 6.10 ColorInterpolator</h2>

<pre>
<b>ColorInterpolator { </b>
  eventIn      SFFloat set_fraction        # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>key           []    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFColor <b>keyValue      []</b>    # [0,1]
  eventOut     SFColor value_changed
<b>}</b></pre>

<p>This node interpolates among a list of MFColor key values to produce
an SFColor (RGB) <i>value_changed</i> event. The number of colours in the
<i>keyValue</i> field shall be equal to the number of keyframes in the <i>key</i>
field. The <i>keyValue</i> field and <i>value_changed</i> events are defined
in RGB colour space. A linear interpolation using the value of <i>set_fraction</i>
as input is performed in HSV space (see <a HREF="bibliography.html#[FOLE]">E.[FOLE]</a>
for description of RGB and HSV colour spaces). The results are undefined
when interpolating between two consecutive keys with complementary hues.</p>

<p><a HREF="concepts.html#4.6.8">4.6.8, Interpolator nodes</a>, contains
a detailed discussion of interpolators.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Cone"></a>6.11 Cone</h2>

<pre>
<b>Cone { </b>
  field     SFFloat   <b>bottomRadius 1        </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field     SFFloat   <b>height       2        </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field     SFBool   <b> side         TRUE</b>
  field     SFBool    <b>bottom       TRUE</b>
}</pre>

<p>The Cone node specifies a cone which is centred in the local coordinate
system and whose central axis is aligned with the local Y-axis. The <i>bottomRadius</i>
field specifies the radius of the cone's base, and the <i>height</i> field
specifies the height of the cone from the centre of the base to the apex.
By default, the cone has a radius of 1.0 at the bottom and a height of 2.0,
with its apex at y = <i>height</i>/2 and its bottom at y = -<i>height</i>/2.
Both <i>bottomRadius</i> and <i>height</i> shall be greater than zero. <a HREF="nodesref.html#Figure6.3">Figure 6.3</a> illustrates the Cone node.</p>

<p><center><a NAME="Figure6.3"></a><img SRC="../Images/cone.gif" WIDTH="356" HEIGHT="386" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/cone.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Cone node"></center></p>

<h4><center>Figure 6.3 -- Cone node</center></h4>

<p>The <i>side</i> field specifies whether sides of the cone are created
and the <i>bottom</i> field specifies whether the bottom cap of the cone
is created. A value of TRUE specifies that this part of the cone exists,
while a value of FALSE specifies that this part does not exist (not rendered
or eligible for collision or sensor intersection tests).</p>

<p>When a texture is applied to the sides of the cone, the texture wraps
counterclockwise (from above) starting at the back of the cone. The texture
has a vertical seam at the back in the X=0&nbsp;plane, from the apex (0,&nbsp;<i>height</i>/2,&nbsp;0)
to the point (0,&nbsp;-<i>height</i>/2,&nbsp;-<i>bottomRadius</i>). For
the bottom cap, a circle is cut out of the texture square centred at (0,&nbsp;-<i>height</i>/2,&nbsp;0)
with dimensions (2&nbsp;×&nbsp;<i>bottomRadius)</i> by (2&nbsp;×&nbsp;<i>bottomRadius)</i>.
The bottom cap texture appears right side up when the top of the cone is
rotated towards the -Z-axis. <a HREF="nodesref.html#TextureTransform">TextureTransform</a>
affects the texture coordinates of the Cone.</p>

<p>The Cone geometry requires outside faces only. When viewed from the inside
the results are undefined.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Coordinate"></a>6.12 Coordinate</h2>

<pre>
<b>Coordinate { </b>
  exposedField MFVec3f <b>point  []      </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>This node defines a set of 3D coordinates to be used in the <i>coord</i>
field of vertex-based geometry nodes including IndexedFaceSet, IndexedLineSet,
and PointSet.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="CoordinateInterpolator"></a>6.13 CoordinateInterpolator</h2>

<pre>
<b>CoordinateInterpolator { </b>
  eventIn      SFFloat set_fraction<b>        </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>key           []    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFVec3f <b><tt>keyValue</tt></b> <b>     []    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     MFVec3f value_changed
<b>}</b></pre>

<p>This node linearly interpolates among a list of MFVec3f values. The number
of coordinates in the <i>keyValue</i> field shall be an integer multiple
of the number of keyframes in the <i>key</i> field. That integer multiple
defines how many coordinates will be contained in the <i>value_changed </i>events.</p>

<p><a HREF="concepts.html#4.6.8">4.6.8, Interpolator nodes</a>, contains
a more detailed discussion of interpolators.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Cylinder"></a>6.14 Cylinder</h2>

<pre>
<b>Cylinder { </b>
  field    SFBool    <b>bottom  TRUE</b>
  field    SFFloat   <b>height  2         </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field    SFFloat   <b>radius  1         </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field    SFBool    <b>side    TRUE</b>
  field    SFBool    <b>top     TRUE</b>
<b>}</b></pre>

<p>The Cylinder node specifies a capped cylinder centred at (0,0,0) in the
local coordinate system and with a central axis oriented along the local
Y-axis. By default, the cylinder is sized at &quot;-1&quot; to &quot;+1&quot;
in all three dimensions. The <i>radius</i> field specifies the radius of
the cylinder and the <i>height</i> field specifies the height of the cylinder
along the central axis. Both <i>radius</i> and <i>height</i> shall be greater
than zero. <a HREF="nodesref.html#Figure6.4">Figure 6.4</a> illustrates the Cylinder
node.</p>

<p>The cylinder has three <i>parts</i>: the <i>side</i>, the <i>top</i>
(Y&nbsp;=&nbsp;+height/2) and the <i>bottom</i> (Y&nbsp;=&nbsp;-height/2).
Each part has an associated SFBool field that indicates whether the part
exists (TRUE) or does not exist (FALSE). Parts which do not exist are not
rendered and not eligible for intersection tests (e.g.,&nbsp;collision detection
or sensor activation).</p>

<p><center><a NAME="Figure6.4"></a><img SRC="../Images/cylinder.gif" WIDTH="452" HEIGHT="392" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/cylinder.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Cylinder node"></center></p>

<h4><center>Figure 6.4 -- Cylinder node</center></h4>

<p>When a texture is applied to a cylinder, it is applied differently to
the sides, top, and bottom. On the sides, the texture wraps counterclockwise
(from above) starting at the back of the cylinder. The texture has a vertical
seam at the back, intersecting the X=0 plane. For the top and bottom caps,
a circle is cut out of the unit texture squares centred at (0, +/- <i>height/2</i>,
0) with dimensions 2&nbsp;×&nbsp;<i>radius</i> by 2&nbsp;×&nbsp;<i>radius</i>.
The top texture appears right side up when the top of the cylinder is tilted
toward the +Z-axis, and the bottom texture appears right side up when the
top of the cylinder is tilted toward the -Z-axis. <a HREF="nodesref.html#TextureTransform">TextureTransform</a>
affects the texture coordinates of the Cylinder node.</p>

<p>The Cylinder node's geometry requires outside faces only. When viewed
from the inside the results are undefined.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="CylinderSensor"></a>6.15 CylinderSensor</h2>

<pre>
<b>CylinderSensor { </b>
  exposedField SFBool     <b>autoOffset</b> <b>TRUE</b>
  exposedField SFFloat    <b>diskAngle  0.262       </b># (0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2)
  exposedField SFBool    <b> enabled    TRUE</b>
  exposedField SFFloat    <b>maxAngle   -1          </b># [-2<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">,2<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">]
  exposedField SFFloat    <b>minAngle   0           </b># [-2<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">,2<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">]
  exposedField SFFloat    <b>offset</b>     <b>0           </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFBool     isActive
  eventOut     SFRotation rotation_changed
  eventOut     SFVec3f    trackPoint_changed
<b>}</b></pre>

<p>The CylinderSensor node maps pointer motion (e.g.,&nbsp;a mouse or wand)
into a rotation on an invisible cylinder that is aligned with the Y-axis
of the local coordinate system. The CylinderSensor uses the descendent geometry
of its parent node to determine whether it is liable to generate events.</p>

<p>The <i>enabled</i> exposed field enables and disables the CylinderSensor
node. If TRUE, the sensor reacts appropriately to user events. If FALSE,
the sensor does not track user input or send events. If <i>enabled</i> receives
a FALSE event and <i>isActive</i> is TRUE, the sensor becomes disabled and
deactivated, and outputs an <i>isActive</i> FALSE event. If <i>enabled</i>
receives a TRUE event the sensor is enabled and ready for user activation.</p>

<p>A CylinderSensor node generates events when the pointing device is activated
while the pointer is indicating any descendent geometry nodes of the sensor's
parent group. See <a HREF="concepts.html#4.6.7.5">4.6.7.5,&nbsp;Activating&nbsp;and&nbsp;manipulating&nbsp;sensors</a>,
for more details on using the pointing device to activate the CylinderSensor.</p>

<p>Upon activation of the pointing device while indicating the sensor's
geometry, an <i>isActive</i> TRUE event is sent. The initial acute angle
between the bearing vector and the local Y-axis of the CylinderSensor node
determines whether the sides of the invisible cylinder or the caps (disks)
are used for manipulation. If the initial angle is less than the <i>diskAngle</i>,
the geometry is treated as an infinitely large disk lying in the local Y=0
plane and coincident with the initial intersection point. Dragging motion
is mapped into a rotation around the local +Y-axis vector of the sensor's
coordinate system. The perpendicular vector from the initial intersection
point to the Y-axis defines zero rotation about the Y-axis. For each subsequent
position of the bearing, a <i>rotation_changed</i> event is sent that equals
the sum of the rotation about the +Y-axis vector (from the initial intersection
to the new intersection) plus the <i>offset</i> value. <i>trackPoint_changed</i>
events reflect the unclamped drag position on the surface of this disk.
When the pointing device is deactivated and <i>autoOffset</i> is TRUE, <i>offset</i>
is set to the last value of <i>rotation_changed</i> and an <i>offset_changed</i>
event is generated. See <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag sensors</a>,
for a more general description of <i>autoOffset</i> and <i>offset</i> fields.</p>

<p>If the initial acute angle between the bearing vector and the local Y-axis
of the CylinderSensor node is greater than or equal to <i>diskAngle</i>,
then the sensor behaves like a cylinder. The shortest distance between the
point of intersection (between the bearing and the sensor's geometry) and
the Y-axis of the parent group's local coordinate system determines the
radius of an invisible cylinder used to map pointing device motion and marks
the zero rotation value. For each subsequent position of the bearing, a
<i>rotation_changed</i> event is sent that equals the sum of the right-handed
rotation from the original intersection about the +Y-axis vector plus the
<i>offset</i> value. <i>trackPoint_changed</i> events reflect the unclamped
drag position on the surface of the invisible cylinder. When the pointing
device is deactivated and <i>autoOffset</i> is TRUE, <i>offset</i> is set
to the last rotation angle and an <i>offset_changed</i> event is generated.
More details are available in <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>.</p>

<p>When the sensor generates an <i>isActive</i> TRUE event, it grabs all
further motion events from the pointing device until it is released and
generates an <i>isActive</i> FALSE event (other pointing-device sensors
shall not generate events during this time). Motion of the pointing device
while <i>isActive</i> is TRUE is referred to as a &quot;drag.&quot; If a
2D pointing device is in use, <i>isActive</i> events will typically reflect
the state of the primary button associated with the device (i.e.,&nbsp;<i>isActive</i>
is TRUE when the primary button is pressed and FALSE when it is released).
If a 3D pointing device (e.g.,&nbsp;a wand) is in use, <i>isActive</i> events
will typically reflect whether the pointer is within or in contact with
the sensor's geometry.</p>

<p>While the pointing device is activated,<i> trackPoint_changed</i> and
<i>rotation_changed</i> events are output and are interpreted from pointing
device motion based on the sensor's local coordinate system at the time
of activation. <i>trackPoint_changed</i> events represent the unclamped
intersection points on the surface of the invisible cylinder or disk. If
the initial angle results in cylinder rotation (as opposed to disk behaviour)
and if the pointing device is dragged off the cylinder while activated,
browsers may interpret this in a variety of ways (e.g., clamp all values
to the cylinder and continuing to rotate as the point is dragged away from
the cylinder). Each movement of the pointing device while <i>isActive</i>
is TRUE generates <i>trackPoint_changed</i> and <i>rotation_changed</i>
events.</p>

<p>The <i>minAngle</i> and <i>maxAngle</i> fields clamp <i>rotation_changed</i>
events to a range of values. If <i>minAngle</i> is greater than <i>maxAngle</i>,
<i>rotation_changed</i> events are not clamped. The <i>minAngle</i> and
<i>maxAngle</i> fields are restricted to the range [-2<img SRC="../Images/pi.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">, 2<img SRC="../Images/pi.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">].</p>

<p>More information about this behaviour is described in <a HREF="concepts.html#4.6.7.3">4.6.7.3,
Pointing-device sensors</a>, <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>, and <a HREF="concepts.html#4.6.7.5">4.6.7.5, Activating and
manipulating sensors</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="DirectionalLight"></a>6.16 DirectionalLight</h2>

<pre>
<b>DirectionalLight { </b>
  exposedField SFFloat <b>ambientIntensity  0</b>        # [0,1]
  exposedField SFColor <b>color             1 1 1</b>    # [0,1]
  exposedField SFVec3f <b>direction         0 0 -1   </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat <b>intensity         1 </b>       # [0,1]
  exposedField SFBool  <b>on                TRUE </b>
<b>}</b></pre>

<p>The DirectionalLight node defines a directional light source that illuminates
along rays parallel to a given 3-dimensional vector. A description of the
<i>ambientIntensity</i>, <i>color</i>, <i>intensity</i>, and <i>on</i> fields
is in <a HREF="concepts.html#4.6.6">4.6.6, Light sources</a>.</p>

<p>The <i>direction </i>field specifies the direction vector of the illumination
emanating from the light source in the local coordinate system. Light is
emitted along parallel rays from an infinite distance away. A directional
light source illuminates only the objects in its enclosing parent group.
The light may illuminate everything within this coordinate system, including
all children and descendants of its parent group. The accumulated transformations
of the parent nodes affect the light.</p>

<p>DirectionalLight nodes do not attenuate with distance. A precise description
of VRML's lighting equations is contained in <a HREF="concepts.html#4.14">4.14,
Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="ElevationGrid"></a>6.17 ElevationGrid</h2>

<pre>
<b>ElevationGrid { </b>
  eventIn      MFFloat  set_height
  exposedField SFNode   <b>color             NULL</b>
  exposedField SFNode  <b> normal            NULL</b>
  exposedField SFNode   <b>texCoord          NULL</b>
  field        MFFloat <b> height            []      # </b>(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFBool   <b>ccw               TRUE</b>
  field        SFBool  <b> colorPerVertex    TRUE</b>
  field        SFFloat  <b>creaseAngle       0       </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">]
  field        SFBool <b>  normalPerVertex   TRUE</b>
  field        SFBool   <b>solid             TRUE</b>
  field        SFInt32  <b>xDimension        0    </b>   # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFFloat  <b>xSpacing          1.0     # </b>(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFInt32  <b>zDimension        0    </b>   # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFFloat  <b>zSpacing          1.0     # </b>(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The ElevationGrid node specifies a uniform rectangular grid of varying
height in the Y=0 plane of the local coordinate system. The geometry is
described by a scalar array of height values that specify the height of
a surface above each point of the grid.</p>

<p>The <i>xDimension</i> and <i>zDimension</i> fields indicate the number
of elements of the grid <i>height</i> array in the X and Z directions. Both
<i>xDimension</i> and <i>zDimension</i> shall be greater than or equal to
zero. If either the <i>xDimension</i> or the <i>zDimension</i> is less than
two, the ElevationGrid contains no quadrilaterals. The vertex locations
for the rectangles are defined by the <i>height</i> field and the <i>xSpacing</i>
and <i>zSpacing</i> fields:</p>

<ul>
  <li>The <i>height</i> field is an <i>xDimension</i> by <i>zDimension</i>
  array of scalar values representing the height above the grid for each
  vertex.
  <li>The <i>xSpacing</i> and <i>zSpacing</i> fields indicate the distance
  between vertices in the X and Z directions respectively, and shall be greater
  than zero.
</ul>

<p>Thus, the vertex corresponding to the point P[i, j] on the grid is placed
at:</p>

<pre>
    P[i,j].x = xSpacing × i
    P[i,j].y = height[ i + j × xDimension]
    P[i,j].z = zSpacing × j

    where 0 &lt;= i &lt; xDimension and 0 &lt;= j &lt; zDimension,
    and P[0,0] is height[0] units above/below the origin of the local
    coordinate system</pre>

<p>The <i>set_height</i> eventIn allows the height MFFloat field to be changed
to support animated ElevationGrid nodes.</p>

<p>The <i>color</i> field specifies per-vertex or per-quadrilateral colours
for the ElevationGrid node depending on the value of <i>colorPerVertex</i>.
If the <i>color</i> field is NULL, the ElevationGrid node is rendered with
the overall attributes of the Shape node enclosing the ElevationGrid node
(see <a HREF="concepts.html#4.14">4.14,&nbsp;Lighting&nbsp;model</a>).</p>

<p>The <i>colorPerVertex</i> field determines whether colours specified
in the <i>color</i> field are applied to each vertex or each quadrilateral
of the ElevationGrid node. If <i>colorPerVertex</i> is FALSE and the <i>color</i>
field is not NULL, the <i>color</i> field shall specify a Color node containing
at least (<i>xDimension-1)</i>×(<i>zDimension-1)</i> colours; one
for each quadrilateral, ordered as follows:</p>

<pre>
    QuadColor[i,j] = Color[ i + j × (xDimension-1)]

    where 0 &lt;= i &lt; xDimension-1 and 0 &lt;= j &lt; zDimension-1,
    and QuadColor[i,j] is the colour for the quadrilateral defined
        by height[i+j×xDimension], height[(i+1)+j×xDimension],
        height[(i+1)+(j+1)×xDimension] and height[i+(j+1)×xDimension]</pre>

<p>If <i>colorPerVertex</i> is TRUE and the <i>color</i> field is not NULL,
the <i>color</i> field shall specify a Color node containing at least <i>xDimension&nbsp;</i>×&nbsp;<i>zDimension</i>
colours, one for each vertex, ordered as follows:</p>

<pre>
    VertexColor[i,j] = Color[ i + j × xDimension]

    where 0 &lt;= i &lt; xDimension and 0 &lt;= j &lt; zDimension,
    and VertexColor[i,j] is the colour for the vertex defined by
        height[i+j×xDimension]</pre>

<p>The <i>normal</i> field specifies per-vertex or per-quadrilateral normals
for the ElevationGrid node. If the <i>normal</i> field is NULL, the browser
shall automatically generate normals, using the <i>creaseAngle</i> field
to determine if and how normals are smoothed across the surface (see <a HREF="concepts.html#4.6.3.5">4.6.3.5, Crease angle field</a>).</p>

<p>The <i>normalPerVertex</i> field determines whether normals are applied
to each vertex or each quadrilateral of the ElevationGrid node depending
on the value of <i>normalPerVertex</i>. If <i>normalPerVertex</i> is FALSE
and the <i>normal</i> node is not NULL, the <i>normal</i> field shall specify
a Normal node containing at least (<i>xDimension-1)</i>×(<i>zDimension-1)
</i>normals; one for each quadrilateral, ordered as follows:</p>

<pre>
    QuadNormal[i,j] = Normal[ i + j × (xDimension-1)]

    where 0 &lt;= i &lt; xDimension-1 and 0 &lt;= j &lt; zDimension-1,
    and QuadNormal[i,j] is the normal for the quadrilateral defined
        by height[i+j×xDimension], height[(i+1)+j×xDimension],
        height[(i+1)+(j+1)×xDimension] and height[i+(j+1)×xDimension]</pre>

<p>If <i>normalPerVertex</i> is TRUE and the <i>normal </i>field is not
NULL, the <i>normal </i>field shall specify a Normal node containing at
least <i>xDimension&nbsp;</i>×&nbsp;<i>zDimension</i> normals; one
for each vertex, ordered as follows:</p>

<pre>
    VertexNormal[i,j] = Normal[ i + j × xDimension]

    where 0 &lt;= i &lt; xDimension and 0 &lt;= j &lt; zDimension,
    and VertexNormal[i,j] is the normal for the vertex defined
        by height[i+j×xDimension]</pre>

<p>The <i>texCoord</i> field specifies per-vertex texture coordinates for
the ElevationGrid node. If <i>texCoord</i> is NULL, default texture coordinates
are applied to the geometry. The default texture coordinates range from
(0,0) at the first vertex to (1,1) at the last vertex. The S texture coordinate
is aligned with the positive X-axis, and the T texture coordinate with positive
Z-axis. If <i>texCoord</i> is not NULL, it shall specify a TextureCoordinate
node containing at least (<i>xDimension)</i>×(<i>zDimension)</i> texture
coordinates; one for each vertex, ordered as follows:</p>

<pre>
    VertexTexCoord[i,j] = TextureCoordinate[ i + j × xDimension]

    where 0 &lt;= i &lt; xDimension and 0 &lt;= j &lt; zDimension,
    and VertexTexCoord[i,j] is the texture coordinate for the vertex
        defined by height[i+j×xDimension]</pre>

<p>The <i>ccw</i>, <i>solid</i>, and <i>creaseAngle</i> fields are described
in <a HREF="concepts.html#4.6.3">4.6.3, Shapes and geometry</a>.</p>

<p>By default, the quadrilaterals are defined with a counterclockwise ordering.
Hence, the Y-component of the normal is positive. Setting the <i>ccw</i>
field to FALSE reverses the normal direction. Backface culling is enabled
when the <i>solid</i> field is TRUE.</p>

<p>See <a HREF="nodesref.html#Figure6.5">Figure 6.5</a> for a depiction of the ElevationGrid
node.</p>

<p><center><a NAME="Figure6.5"></a><img SRC="../Images/ElevationGrid.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/ElevationGrid.gif" WIDTH="527" HEIGHT="335" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="ElevationGrid node"></center></p>

<h4><center>Figure 6.5 -- ElevationGrid node</center></h4>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Extrusion"></a>6.18 Extrusion</h2>

<pre>
<b>Extrusion { </b>
  eventIn MFVec2f    set_crossSection
  eventIn MFRotation set_orientation
  eventIn MFVec2f    set_scale
  eventIn MFVec3f    set_spine
  field   SFBool     <b>beginCap         TRUE</b>
  field   SFBool     <b>ccw              TRUE</b>
  field   SFBool     <b>convex           TRUE</b>
  field   SFFloat    <b>creaseAngle      0        </b>        # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field   MFVec2f    <b>crossSection     [ 1 1, 1 -1, -1 -1,</b>
<b>                                       -1 1, 1  1 ]    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field   SFBool     <b>endCap           TRUE</b>
  field   MFRotation <b>orientation      0 0 1 0          </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field   MFVec2f    <b>scale            1 1              </b># (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field   SFBool     <b>solid            TRUE</b>
  field   MFVec3f    <b>spine            [ 0 0 0, 0 1 0 ] </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<h4>6.18.1 Introduction</h4>

<p>The Extrusion node specifies geometric shapes based on a two dimensional
cross-section extruded along a three dimensional spine in the local coordinate
system. The cross-section can be scaled and rotated at each spine point
to produce a wide variety of shapes.</p>

<p>An Extrusion node is defined by:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>a 2D <i>crossSection</i> piecewise linear curve (described as a series
  of connected vertices);
  <li>a 3D <i>spine</i> piecewise linear curve (also described as a series
  of connected vertices);
  <li>a list of 2D <i>scale</i> parameters;
  <li>a list of 3D <i>orientation</i> parameters.
</ol><!--/NOEDIT--></p>

<h4>6.18.2 Algorithmic description</h4>

<p>Shapes are constructed as follows. The cross-section curve, which starts
as a curve in the Y=0 plane, is first scaled about the origin by the first
<i>scale</i> parameter (first value scales in X, second value scales in
Z). It is then translated by the first spine point and oriented using the
first <i>orientation</i> parameter (as explained later). The same procedure
is followed to place a cross-section at the second spine point, using the
second scale and orientation values. Corresponding vertices of the first
and second cross-sections are then connected, forming a quadrilateral polygon
between each pair of vertices. This same procedure is then repeated for
the rest of the spine points, resulting in a surface extrusion along the
spine.</p>

<p>The final orientation of each cross-section is computed by first orienting
it relative to the spine segments on either side of point at which the cross-section
is placed. This is known as the <i>spine-aligned cross-section plane</i>
(SCP), and is designed to provide a smooth transition from one spine segment
to the next (see <a HREF="nodesref.html#Figure6.6">Figure&nbsp;6.6</a>). The SCP is then
rotated by the corresponding <i>orientation</i> value. This rotation is
performed relative to the SCP. For example, to impart twist in the cross-section,
a rotation about the Y-axis (0 1 0) would be used. Other orientations are
valid and rotate the cross-section out of the SCP.</p>

<p><center><a NAME="Figure6.6"></a><img SRC="../Images/Extrusion.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/Extrusion.gif" WIDTH="538" HEIGHT="455" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Spine-aligned cross-section plane at a spine point"></center></p>

<h4><center>Figure 6.6 -- Spine-aligned cross-section plane at a spine point.</center></h4>

<p>The SCP is computed by first computing its Y-axis and Z-axis, then taking
the cross product of these to determine the X-axis. These three axes are
then used to determine the rotation value needed to rotate the Y=0 plane
to the SCP. This results in a plane that is the approximate tangent of the
spine at each point, as shown in <a HREF="nodesref.html#Figure6.6">Figure 6.6</a>. First
the Y-axis is determined, as follows:</p>

<p>&nbsp;&nbsp;&nbsp;Let n be the number of spines and let i be the index
variable satisfying 0 &lt;= i &lt; n:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li><i>For all points other than the first or last:</i> The Y-axis for
  <i>spine</i>[i] is found by normalizing the vector defined by (<i>spine</i>[i+1]
  - <i>spine</i>[i-1]).
  <li><i>If the spine curve is closed:</i> The SCP for the first and last
  points is the same and is found using (<i>spine</i>[1] - <i>spine</i>[n-2])
  to compute the Y-axis.
  <li><i>If the spine curve is not closed:</i> The Y-axis used for the first
  point is the vector from <i>spine</i>[0] to <i>spine</i>[1], and for the
  last it is the vector from <i>spine</i>[<i>n</i>-2] to <i>spine</i>[<i>n</i>-1].
</ol><!--/NOEDIT--></p>

<p>The Z-axis is determined as follows:</p>

<p><!--NOEDIT--><ol START="4" TYPE="a">
  <li><i>For all points other than the first or last:</i> Take the following
  cross-product: <pre>Z = (spine[i+1] - spine[i]) × (spine[i-1] - spine[i])
  </pre>
  <li><i>If the spine curve is closed:</i> The SCP for the first and last
  points is the same and is found by taking the following cross-product:
  <pre>Z = (spine[1] - spine[0]) × (spine[n-2] - spine[0]) </pre>
  <li><i>If the spine curve is not closed:</i> The Z-axis used for the first
  spine point is the same as the Z-axis for spine[1]. The Z-axis used for
  the last spine point is the same as the Z-axis for spine[n-2].
  <li>After determining the Z-axis, its dot product with the Z-axis of the
  previous spine point is computed. If this value is negative, the Z-axis
  is flipped (multiplied by -1). In most cases, this prevents small changes
  in the spine segment angles from flipping the cross-section 180 degrees.
</ol><!--/NOEDIT--></p>

<p>Once the Y- and Z-axes have been computed, the X-axis can be calculated
as their cross-product.</p>

<h4>6.18.3 Special cases</h4>

<p>If the number of <i>scale</i> or <i>orientation</i> values is greater
than the number of spine points, the excess values are ignored. If they
contain one value, it is applied at all spine points. The results are undefined
if the number of scale or orientation values is greater than one but less
than the number of spine points. The <i>scale</i> values shall be positive.</p>

<p>If the three points used in computing the Z-axis are collinear, the cross-product
is zero so the value from the previous point is used instead.</p>

<p>If the Z-axis of the first point is undefined (because the spine is not
closed and the first two spine segments are collinear) then the Z-axis for
the first spine point with a defined Z-axis is used.</p>

<p>If the entire spine is collinear, the SCP is computed by finding the
rotation of a vector along the positive Y-axis (<tt>v1</tt>) to the vector
formed by the spine points (<tt>v2</tt>). The Y=0 plane is then rotated
by this value.</p>

<p>If two points are coincident, they both have the same SCP. If each point
has a different orientation value, then the surface is constructed by connecting
edges of the cross-sections as normal. This is useful in creating revolved
surfaces.</p>

<p><i>Note: combining coincident and non-coincident spine segments, as well
as other combinations, can lead to interpenetrating surfaces which the extrusion
algorithm makes no attempt to avoid. </i></p>

<h4>6.18.4 Common cases</h4>

<p>The following common cases are among the effects which are supported
by the Extrusion node:</p>

<dl>
  <dt><i>Surfaces of revolution:</i>
  <dd>If the cross-section is an approximation of a circle and the spine
  is straight, the Extrusion is equivalent to a surface of revolution, where
  the <i>scale</i> parameters define the size of the cross-section along
  the spine.
  <dt><i>Uniform extrusions:</i>
  <dd>If the <i>scale</i> is (1, 1) and the spine is straight, the cross-section
  is extruded uniformly without twisting or scaling along the spine. The
  result is a cylindrical shape with a uniform cross section.
  <dt><i>Bend/twist/taper objects:</i>
  <dd>These shapes are the result of using all fields. The spine curve bends
  the extruded shape defined by the cross-section, the orientation parameters
  (given as rotations about the Y-axis) twist it around the spine, and the
  scale parameters taper it (by scaling about the spine).
</dl>

<h4>6.18.5 Other fields</h4>

<p>Extrusion has three <i>parts</i>: the sides, the <i>beginCap</i> (the
surface at the initial end of the spine) and the <i>endCap</i> (the surface
at the final end of the spine). The caps have an associated SFBool field
that indicates whether each exists (TRUE) or doesn't exist (FALSE).</p>

<p>When the <i>beginCap</i> or <i>endCap</i> fields are specified as TRUE,
planar cap surfaces will be generated regardless of whether the <i>crossSection</i>
is a closed curve. If <i>crossSection</i> is not a closed curve, the caps
are generated by adding a final point to <i>crossSection</i> that is equal
to the initial point. An open surface can still have a cap, resulting (for
a simple case) in a shape analogous to a soda can sliced in half vertically.
These surfaces are generated even if <i>spine</i> is also a closed curve.
If a field value is FALSE, the corresponding cap is not generated.</p>

<p>Texture coordinates are automatically generated by Extrusion nodes. Textures
are mapped so that the coordinates range in the U direction from 0 to 1
along the <i>crossSection</i> curve (with 0 corresponding to the first point
in <i>crossSection</i> and 1 to the last) and in the V direction from 0
to 1 along the <i>spine</i> curve (with 0 corresponding to the first listed
<i>spine</i> point and 1 to the last). If either the <i>endCap</i> or <i>beginCap</i>
exists, the <i>crossSection</i> curve is uniformly scaled and translated
so that the larger dimension of the cross-section (X or Z) produces texture
coordinates that range from 0.0 to 1.0. The <i>beginCap</i> and <i>endCap</i>
textures' S and T directions correspond to the X and Z directions in which
the <i>crossSection</i> coordinates are defined.</p>

<p>The browser shall automatically generate normals for the Extrusion node,using
the <i>creaseAngle</i> field to determine if and how normals are smoothed
across the surface. Normals for the caps are generated along the Y-axis
of the SCP, with the ordering determined by viewing the cross-section from
above (looking along the negative Y-axis of the SCP). By default, a <i>beginCap</i>
with a counterclockwise ordering shall have a normal along the negative
Y-axis. An <i>endCap</i> with a counterclockwise ordering shall have a normal
along the positive Y-axis.</p>

<p>Each quadrilateral making up the sides of the extrusion are ordered from
the bottom cross-section (the one at the earlier spine point) to the top.
So, one quadrilateral has the points:</p>

<pre>
    spine[0](crossSection[0], crossSection[1])
    spine[1](crossSection[1], crossSection[0])</pre>

<p>in that order. By default, normals for the sides are generated as described
in <a HREF="concepts.html#4.6.3">4.6.3,&nbsp;Shapes&nbsp;and&nbsp;geometry</a>.</p>

<p>For instance, a circular crossSection with counter-clockwise ordering
and the default spine form a cylinder. With <i>solid</i> TRUE and <i>ccw</i>
TRUE, the cylinder is visible from the outside. Changing <i>ccw</i> to FALSE
makes it visible from the inside.</p>

<p>The <i>ccw</i>, <i>solid</i>, <i>convex</i>, and <i>creaseAngle</i> fields
are described in <a HREF="concepts.html#4.6.3">4.6.3, Shapes and geometry</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Fog"></a>6.19 Fog</h2>

<pre>
<b>Fog { </b>
  exposedField SFColor  <b>color            1 1 1 </b>     # [0,1]
  exposedField SFString <b>fogType          &quot;LINEAR&quot;</b>
  exposedField SFFloat  <b>visibilityRange  0</b>          # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventIn      SFBool   set_bind
  eventOut     SFBool   isBound
<b>}</b></pre>

<p>The Fog node provides a way to simulate atmospheric effects by blending
objects with the colour specified by the <i>color</i> field based on the
distances of the various objects from the viewer. The distances are calculated
in the coordinate space of the Fog node. The <i>visibilityRange</i> specifies
the distance in metres (in the local coordinate system) at which objects
are totally obscured by the fog. Objects located outside the <i>visibilityRange</i>
from the viewer are drawn with a constant colour of <i>color</i>. Objects
very close to the viewer are blended very little with the fog <i>color</i>.
A <i>visibilityRange</i> of 0.0 disables the Fog node. The <i>visibilityRange</i>
is affected by the scaling transformations of the Fog node's parents; translations
and rotations have no affect on <i>visibilityRange</i>. Values of the <i>visibilityRange</i>
field shall be in the range [0,&nbsp;<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">).</p>

<p>Since Fog nodes are bindable children nodes (see <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable
children nodes</a>), a Fog node stack exists, in which the top-most Fog
node on the stack is currently active. To push a Fog node onto the top of
the stack, a TRUE value is sent to the <i>set_bind</i> eventIn. Once active,
the Fog node is bound to the browser view. A FALSE value sent to <i>set_bind</i>,
pops the Fog node from the stack and unbinds it from the browser viewer.
More details on the Fog node stack can be found in <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable
children nodes</a>.</p>

<p>The <i>fogType</i> field controls how much of the fog colour is blended
with the object as a function of distance. If <i>fogType</i> is &quot;LINEAR&quot;,
the amount of blending is a linear function of the distance, resulting in
a depth cueing effect. If <i>fogType</i> is &quot;EXPONENTIAL,&quot; an
exponential increase in blending is used, resulting in a more natural fog
appearance.</p>

<p>The effect of fog on lighting calculations is described in <a HREF="concepts.html#4.14">4.14,
Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="FontStyle"></a>6.20 FontStyle</h2>

<pre>
<b>FontStyle { </b>
  field MFString <b>family       &quot;SERIF&quot;</b>
  field SFBool   <b>horizontal   TRUE</b>
  field MFString <b>justify      &quot;BEGIN&quot;</b>
  field SFString <b>language     &quot;&quot;</b>
  field SFBool   <b>leftToRight  TRUE</b>
  field SFFloat  <b>size         1.0</b>          # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field SFFloat  <b>spacing      1.0</b>          # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field SFString <b>style        &quot;PLAIN&quot;</b>
  field SFBool   <b>topToBottom  TRUE</b>
<b>}</b></pre>

<h4>6.20.1 Introduction</h4>

<p>The FontStyle node defines the size, family, and style used for Text
nodes, as well as the direction of the text strings and any language-specific
rendering techniques used for non-English text. See <a HREF="nodesref.html#Text">6.47,&nbsp;Text</a>,
for a description of the Text node.</p>

<p>The <i>size</i> field specifies the nominal height, in the local coordinate
system of the Text node, of glyphs rendered and determines the spacing of
adjacent lines of text. Values of the <i>size</i> field shall be greater
than zero.</p>

<p>The <i>spacing</i> field determines the line spacing between adjacent
lines of text. The distance between the baseline of each line of text is
(<i>spacing&nbsp;</i>×&nbsp;<i>size)</i> in the appropriate direction
(depending on other fields described below). The effects of the <i>size</i>
and <i>spacing</i> field are depicted in <a HREF="nodesref.html#Figure6.7">Figure 6.7</a>
(<i>spacing&nbsp;</i>greater than&nbsp;1.0). Values of the <i>spacing</i>
field shall be non-negative.</p>

<p><center><a NAME="Figure6.7"></a><img SRC="../Images/FontStylespacing.gif" WIDTH="431" HEIGHT="103" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="FontStyle node example"></center></p>

<h4><center>Figure 6.7 -- Text <i>size</i> and <i>spacing</i> fields<br>
<br>
</center></h4>

<h4>6.20.2 Font family and style</h4>

<p>Font attributes are defined with the <i>family</i> and <i>style</i> fields.
The browser shall map the specified font attributes to an appropriate available
font as described below.</p>

<p>The <i>family</i> field contains a case-sensitive MFString value that
specifies a sequence of font family names in preference order. The browser
shall search the MFString value for the first font family name matching
a supported font family. If none of the string values matches a supported
font family, the default font family <b>&quot;SERIF&quot;</b> shall be used.
All browsers shall support at least <b>&quot;SERIF&quot;</b> (the default)
for a serif font such as Times Roman; <b>&quot;SANS&quot;</b> for a sans-serif
font such as Helvetica; and <b>&quot;TYPEWRITER&quot;</b> for a fixed-pitch
font such as Courier. An empty <i>family</i> value is identical to <b>[&quot;SERIF&quot;]</b>.</p>

<p>The <i>style</i> field specifies a case-sensitive SFString value that
may be <b>&quot;PLAIN&quot;</b> (the default) for default plain type; <b>&quot;BOLD&quot;</b>
for boldface type; <b>&quot;ITALIC&quot;</b> for italic type; or <b>&quot;BOLDITALIC&quot;</b>
for bold and italic type. An empty <i>style</i> value (<b>&quot;&quot;)</b>
is identical to <b>&quot;PLAIN&quot;</b>.</p>

<h4>6.20.3 Direction and justification</h4>

<p>The <i>horizontal</i>, <i>leftToRight</i>, and <i>topToBottom</i> fields
indicate the direction of the text. The <i>horizontal</i> field indicates
whether the text advances horizontally in its major direction (<i>horizontal</i>
= TRUE, the default) or vertically in its major direction (<i>horizontal</i>
= FALSE). The <i>leftToRight</i> and <i>topToBottom</i> fields indicate
direction of text advance in the major (characters within a single string)
and minor (successive strings) axes of layout. Which field is used for the
major direction and which is used for the minor direction is determined
by the <i>horizontal</i> field.</p>

<p>For horizontal text (<i>horizontal</i> = TRUE), characters on each line
of text advance in the positive X direction if <i>leftToRight</i> is TRUE
or in the negative X direction if <i>leftToRight</i> is FALSE. Characters
are advanced according to their natural advance width. Each line of characters
is advanced in the negative Y direction if <i>topToBottom</i> is TRUE or
in the positive Y direction if <i>topToBottom</i> is FALSE. Lines are advanced
by the amount of <i>size&nbsp;</i>×&nbsp;<i>spacing</i>.</p>

<p>For vertical text (<i>horizontal</i> = FALSE), characters on each line
of text advance in the negative Y direction if <i>topToBottom</i> is TRUE
or in the positive Y direction if <i>topToBottom</i> is FALSE. Characters
are advanced according to their natural advance height. Each line of characters
is advanced in the positive X direction if <i>leftToRight</i> is TRUE or
in the negative X direction if <i>leftToRight</i> is FALSE. Lines are advanced
by the amount of <i>size&nbsp;</i>×&nbsp;<i>spacing</i>.</p>

<p>The <i>justify</i> field determines alignment of the above text layout
relative to the origin of the object coordinate system. The <i>justify</i>
field is an MFString which can contain 2 values. The first value specifies
alignment along the major axis and the second value specifies alignment
along the minor axis, as determined by the <i>horizontal</i> field. An empty
<i>justify</i> value (<b>&quot;&quot;)</b> is equivalent to the default
value. If the second string, minor alignment, is not specified, minor alignment
defaults to the value <b>&quot;FIRST&quot;.</b> Thus, <i>justify</i> values
of <b>&quot;&quot;</b>, <b>&quot;BEGIN&quot;</b>, and <b>[&quot;BEGIN&quot;
&quot;FIRST&quot;] </b>are equivalent.</p>

<p>The major alignment is along the X-axis when <i>horizontal</i> is TRUE
and along the Y-axis when <i>horizontal is</i> FALSE. The minor alignment
is along the Y-axis when <i>horizontal</i> is TRUE and along the X-axis
when <i>horizontal is</i> FALSE. The possible values for each enumerant
of the <i>justify</i> field are <b>&quot;FIRST&quot;</b>, <b>&quot;BEGIN&quot;</b>,
<b>&quot;MIDDLE&quot;</b>, and <b>&quot;END&quot;</b>. For major alignment,
each line of text is positioned individually according to the major alignment
enumerant. For minor alignment, the block of text representing all lines
together is positioned according to the minor alignment enumerant. <a HREF="nodesref.html#Table6.2">Tables 6.2-6.5</a> describe the behaviour in terms of which
portion of the text is at the origin</p>

<h4><center><a NAME="Table6.2"></a>Table 6.2 --&nbsp;Major Alignment, <i>horizontal</i>
= TRUE</center></h4>

<p><center><table BORDER="1" CELLPADDING="6" CELLSPACING="6">
<tr>
<td><b><i>justify</i> Enumerant</b></td>
<td><b><i>leftToRight</i> = TRUE</b></td>
<td><b><i>leftToRight</i> = FALSE</b></td></tr>
<tr>
<td>&nbsp;FIRST</td>
<td>&nbsp;Left edge of each line</td>
<td>&nbsp;Right edge of each line</td></tr>
<tr>
<td>&nbsp;BEGIN</td>
<td>&nbsp;Left edge of each line</td>
<td>&nbsp;Right edge of each line</td></tr>
<tr>
<td>&nbsp;MIDDLE</td>
<td>&nbsp;Centred about X-axis</td>
<td>&nbsp;Centred about X-axis</td></tr>
<tr>
<td>&nbsp;END</td>
<td>&nbsp;Right edge of each line</td>
<td>&nbsp;Left edge of each line</td></tr>
</table>
</center></p>

<h4><center><br>
<br>
Table 6.3 --&nbsp;Major Alignment, <i>horizontal</i> = FALSE</center></h4>

<p><center><table BORDER="1" CELLPADDING="6" CELLSPACING="6">
<tr>
<td><b><i>justify</i> Enumerant</b></td>
<td><b><i>topToBottom</i> = TRUE</b></td>
<td><b><i>topToBottom</i> = FALSE</b></td></tr>
<tr>
<td>&nbsp;FIRST</td>
<td>&nbsp;Top edge of each line</td>
<td>&nbsp;Bottom edge of each line</td></tr>
<tr>
<td>&nbsp;BEGIN</td>
<td>&nbsp;Top edge of each line</td>
<td>&nbsp;Bottom edge of each line</td></tr>
<tr>
<td>&nbsp;MIDDLE</td>
<td>&nbsp;Centred about Y-axis</td>
<td>&nbsp;Centre about Y-axis</td></tr>
<tr>
<td>&nbsp;END</td>
<td>&nbsp;Bottom edge of each line</td>
<td>&nbsp;Top edge of each line</td></tr>
</table>
</center></p>

<h4><center><br>
<br>
Table 6.4 --&nbsp;Minor Alignment, <i>horizontal</i> = TRUE</center></h4>

<p><center><table BORDER="1" CELLPADDING="6" CELLSPACING="6">
<tr>
<td><b><i>justify</i> Enumerant</b></td>
<td><b><i>topToBottom</i> = TRUE</b></td>
<td><b><i>topToBottom</i> = FALSE</b></td></tr>
<tr>
<td>&nbsp;FIRST</td>
<td>&nbsp;Baseline of first line</td>
<td>&nbsp;Baseline of first line</td></tr>
<tr>
<td>&nbsp;BEGIN</td>
<td>&nbsp;Top edge of first line</td>
<td>&nbsp;Bottom edge of first line</td></tr>
<tr>
<td>&nbsp;MIDDLE</td>
<td>&nbsp;Centred about Y-axis</td>
<td>&nbsp;Centred about Y-axis</td></tr>
<tr>
<td>&nbsp;END</td>
<td>&nbsp;Bottom edge of last line&nbsp;</td>
<td>&nbsp;Top edge of last line</td></tr>
</table>
</center></p>

<h4><center><br>
<br>
Table 6.5 --&nbsp;Minor Alignment, <i>horizontal</i> = FALSE</center></h4>

<p><center><table BORDER="1" CELLPADDING="6" CELLSPACING="6">
<tr>
<td><b><i>justify</i> Enumerant</b></td>
<td><b><i>leftToRight</i> = TRUE</b></td>
<td><b><i>leftToRight</i> = FALSE</b></td></tr>
<tr>
<td>&nbsp;FIRST</td>
<td>&nbsp;Left edge of first line</td>
<td>&nbsp;Right edge of first line</td></tr>
<tr>
<td>&nbsp;BEGIN</td>
<td>&nbsp;Left edge of first line</td>
<td>&nbsp;Right edge of first line</td></tr>
<tr>
<td>&nbsp;MIDDLE</td>
<td>&nbsp;Centred about X-axis</td>
<td>&nbsp;Centred about X-axis</td></tr>
<tr>
<td>&nbsp;END</td>
<td>&nbsp;Right edge of last line</td>
<td>&nbsp;Left edge of last line</td></tr>
</table>
</center></p>

<p><center><br>
<br>
</center></p>

<p>The default minor alignment is <b>&quot;FIRST&quot;</b>. This is a special
case of minor alignment when <i>horizontal</i> is TRUE. Text starts at the
baseline at the Y-axis. In all other cases, <b>&quot;FIRST&quot;</b> is
identical to <b>&quot;BEGIN&quot;</b>. In <a HREF="nodesref.html#Figure6.8">Tables 6.6
and 6.7</a>, each colour-coded cross-hair indicates where the X-axis and
Y-axis shall be in relation to the text. <a HREF="nodesref.html#Figure6.8">Figure 6.8</a>
describes the symbols used in Tables 6.6 and 6.7.</p>

<h4><center><a NAME="Figure6.8"></a><img SRC="../Images/key.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/key.gif" WIDTH="349" HEIGHT="93" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Key for Tables 6.6 and 6.7"><br>
Figure 6.8 --&nbsp;Key for Tables 6.6 and 6.7<br>
<br>
<br>
Table 6.6 --&nbsp;<i>horizontal</i> = TRUE</center></h4>

<h4><center><img SRC="../Images/horizontal.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/horizontal.gif" WIDTH="633" HEIGHT="278" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="horizontal = TRUE"><br>
<br>
<br>
</center></h4>

<h4><center>Table 6.7 --&nbsp;<i>horizontal = FALSE</i></center></h4>

<h4><center><img SRC="../Images/vertical.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/vertical.gif" WIDTH="630" HEIGHT="483" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="horizontal = FALSE"><br>
<br>
<br>
</center></h4>

<h4>6.20.4 Language</h4>

<p>The <i>language</i> field specifies the context of the language for the
text string. Due to the multilingual nature of the ISO/IEC 10646-1:1993,
the <i>language</i> field is needed to provide a proper language attribute
of the text string. The format is based on RFC 1766: language[_territory]
<a HREF="references.html#[1766]">2.[1766]</a>. The value for the language
tag is based on ISO 639:1988 (e.g.,&nbsp;'zh' for Chinese, 'jp' for Japanese,
and 'sc' for Swedish.) The territory tag is based on ISO 3166:1993 country
codes (e.g.,&nbsp;'TW' for Taiwan and 'CN' for China for the 'zh' Chinese
language tag). If the <i>language</i> field is empty (&quot;&quot;), local
language bindings are used.</p>

<p>See <a HREF="references.html">2, Normative references</a>, for more information
on RFC 1766 (<a HREF="references.html#[1766]">2.[1766]</a>), ISO/IEC 10646:1993
(<a HREF="references.html#[UTF8]">2.[UTF8]</a>), ISO/IEC 639:1998 (<a HREF="references.html#[I639]">2.[I639]</a>), and ISO 3166:1993 (<a HREF="references.html#[I3166]">2.[I3166]</a>).</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Group"></a>6.21 Group</h2>

<pre>
<b>Group { </b>
  eventIn      MFNode  addChildren
  eventIn      MFNode  removeChildren
  exposedField MFNode  <b>children      []</b>
  field        SFVec3f <b>bboxCenter    0 0 0     </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f <b>bboxSize      -1 -1 -1 </b> #&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)&nbsp;or&nbsp;-1,-1,-1
<b>}</b></pre>

<p>A Group node contains children nodes without introducing a new transformation.
It is equivalent to a Transform node containing an identity transform.</p>

<p>More details on the <i>children</i>, <i>addChildren</i>, and <i>removeChildren</i>
fields and eventIns can be found in <a HREF="concepts.html#4.6.5">4.6.5,
Grouping and children nodes</a>.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the Group node's children. This is a hint that may be used
for optimization purposes. The results are undefined if the specified bounding
box is smaller than the actual bounding box of the children at any time.
A default <i>bboxSize</i> value, (-1, -1, -1), implies that the bounding
box is not specified and, if needed, is calculated by the browser. A description
of the <i>bboxCenter</i> and <i>bboxSize</i> fields is contained in <a HREF="concepts.html#4.6.4">4.6.4, Bounding boxes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="ImageTexture"></a>6.22 ImageTexture</h2>

<pre>
<b>ImageTexture { </b>
  exposedField MFString <b>url     []</b>
  field        SFBool   <b>repeatS TRUE</b>
  field        SFBool   <b>repeatT TRUE</b>
<b>}</b></pre>

<p>The ImageTexture node defines a texture map by specifying an image file
and general parameters for mapping to geometry. Texture maps are defined
in a 2D coordinate system (s,&nbsp;t) that ranges from [0.0, 1.0] in both
directions. The bottom edge of the image corresponds to the S-axis of the
texture map, and left edge of the image corresponds to the T-axis of the
texture map. The lower-left pixel of the image corresponds to s=0, t=0,
and the top-right pixel of the image corresponds to s=1, t=1. These relationships
are depicted in <a HREF="nodesref.html#Figure6.9">Figure 6.9</a>.</p>

<p><center><a NAME="Figure6.9"></a><img SRC="../Images/ImageTexture.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/ImageTexture.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED WIDTH="413" HEIGHT="228" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Texture map coord system"></center></p>

<h4><center>Figure 6.9 -- Texture map coordinate system</center></h4>

<p>The texture is read from the URL specified by the <i>url</i> field. When
the <i>url</i> field contains no values ([]), texturing is disabled. Browsers
shall support the JPEG (see <a HREF="references.html#[JPEG]">2.&nbsp;[JPEG]</a>)
and PNG (see&nbsp;<a HREF="references.html#[PNG]">2.&nbsp;[PNG]</a>) image
file formats. In addition, browsers may support other image formats (e.g.&nbsp;CGM,
<a HREF="references.html#[CGM]">2.&nbsp;[CGM]</a>) which can be rendered
into a 2D image. Support for the GIF format (see <a HREF="bibliography.html#[GIF]">E.&nbsp;[GIF]</a>)
is also recommended (including transparency). Details on the <i>url</i>
field can be found in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p>See <a HREF="concepts.html#4.6.11">4.6.11, Texture maps</a>, for a general
description of texture maps.</p>

<p>See <a HREF="concepts.html#4.14">4.14, Lighting model</a>, for a description
of lighting equations and the interaction between textures, materials, and
geometry appearance.</p>

<p>The <i>repeatS</i> and <i>repeatT</i> fields specify how the texture
wraps in the S and T directions. If <i>repeatS</i> is TRUE (the default),
the texture map is repeated outside the [0.0,&nbsp;1.0] texture coordinate
range in the S direction so that it fills the shape. If <i>repeatS</i> is
FALSE, the texture coordinates are clamped in the S direction to lie within
the [0.0,&nbsp;1.0] range. The <i>repeatT</i> field is analogous to the
<i>repeatS</i> field.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="IndexedFaceSet"></a>6.23 IndexedFaceSet</h2>

<pre>
<b>IndexedFaceSet { </b>
  eventIn       MFInt32 set_colorIndex
  eventIn       MFInt32 set_coordIndex
  eventIn       MFInt32 set_normalIndex
  eventIn       MFInt32 set_texCoordIndex
  exposedField  SFNode  <b>color             NULL</b>
  exposedField  SFNode  <b>coord             NULL</b>
  exposedField  SFNode  <b>normal            NULL</b>
  exposedField  SFNode  <b>texCoord          NULL</b>
  field         SFBool  <b>ccw               TRUE</b>
  field         MFInt32 <b>colorIndex        []</b>        # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field         SFBool  <b>colorPerVertex    TRUE</b>
  field         SFBool  <b>convex            TRUE</b>
  field         MFInt32 <b>coordIndex        []      </b>  # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field         SFFloat <b>creaseAngle       0         </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field         MFInt32 <b>normalIndex       []</b>        # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field         SFBool  <b>normalPerVertex   TRUE</b>
  field         SFBool  <b>solid             TRUE</b>
  field         MFInt32<b> texCoordIndex     []</b>        # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The IndexedFaceSet node represents a 3D shape formed by constructing
faces (polygons) from vertices listed in the <i>coord</i> field. The <i>coord</i>
field contains a Coordinate node that defines the 3D vertices referenced
by the <i>coordIndex</i> field. IndexedFaceSet uses the indices in its <i>coordIndex</i>
field to specify the polygonal faces by indexing into the coordinates in
the Coordinate node. An index of &quot;-1&quot; indicates that the current
face has ended and the next one begins. The last face may be (but does not
have to be) followed by a &quot;-1&quot; index. If the greatest index in
the <i>coordIndex</i> field is N, the Coordinate node shall contain N+1
coordinates (indexed as 0 to N). Each face of the IndexedFaceSet shall have:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>at least three non-coincident vertices;
  <li>vertices that define a planar polygon;
  <li>vertices that define a non-self-intersecting polygon.
</ol><!--/NOEDIT--></p>

<p>Otherwise, The results are undefined.</p>

<p>The IndexedFaceSet node is specified in the local coordinate system and
is affected by the transformations of its ancestors.</p>

<p>Descriptions of the <i>coord</i>, <i>normal</i>, and <i>texCoord</i>
fields are provided in the <a HREF="nodesref.html#Coordinate">Coordinate</a>, <a HREF="nodesref.html#Normal">Normal</a>, and <a HREF="nodesref.html#TextureCoordinate">TextureCoordinate</a>
nodes, respectively.</p>

<p>Details on lighting equations and the interaction between <i>color</i>
field, <i>normal</i> field, textures, materials, and geometries are provided
in <a HREF="concepts.html#4.14">4.14, Lighting model</a>.</p>

<p>If the <i>color </i>field is not NULL, it shall contain a Color node
whose colours are applied to the vertices or faces of the IndexedFaceSet
as follows:</p>

<p><!--NOEDIT--><ol START="4" TYPE="a">
  <li>If <i>colorPerVertex</i> is FALSE, colours are applied to each face,
  as follows:
  <ol START="1" TYPE="1">
    <li>If the <i>colorIndex</i> field is not empty, then one colour is used
    for each face of the IndexedFaceSet. There shall be at least as many indices
    in the <i>colorIndex</i> field as there are faces in the IndexedFaceSet.
    If the greatest index in the <i>colorIndex</i> field is N, then there shall
    be N+1 colours in the Color node. The <i>colorIndex</i> field shall not
    contain any negative entries.
    <li>If the <i>colorIndex</i> field is empty, then the colours in the Color
    node are applied to each face of the IndexedFaceSet in order. There shall
    be at least as many colours in the Color node as there are faces.
  </ol>
  <li>If <i>colorPerVertex</i> is TRUE, colours are applied to each vertex,
  as follows:
  <ol START="1" TYPE="1">
    <li>If the <i>colorIndex</i> field is not empty, then colours are applied
    to each vertex of the IndexedFaceSet in exactly the same manner that the
    <i>coordIndex</i> field is used to choose coordinates for each vertex from
    the Coordinate node. The <i>colorIndex</i> field shall contain at least
    as many indices as the <i>coordIndex</i> field, and shall contain end-of-face
    markers (-1) in exactly the same places as the <i>coordIndex</i> field.
    If the greatest index in the <i>colorIndex</i> field is N, then there shall
    be N+1 colours in the Color node.
    <li>If the <i>colorIndex</i> field is empty, then the <i>coordIndex</i>
    field is used to choose colours from the Color node. If the greatest index
    in the <i>coordIndex</i> field is N, then there shall be N+1 colours in
    the Color node.
  </ol>
</ol><!--/NOEDIT--></p>

<p>If the <i>color</i> field is NULL, the geometry shall be rendered normally
using the Material and texture defined in the Appearance node (see <a HREF="concepts.html#4.14">4.14, Lighting model</a>, for details).</p>

<p>If the <i>normal</i> field is not NULL, it shall contain a Normal node
whose normals are applied to the vertices or faces of the IndexedFaceSet
in a manner exactly equivalent to that described above for applying colours
to vertices/faces (where <i>normalPerVertex</i> corresponds to <i>colorPerVertex</i>
and <i>normalIndex</i> corresponds to <i>colorIndex</i>). If the <i>normal</i>
field is NULL, the browser shall automatically generate normals, using <i>creaseAngle</i>
to determine if and how normals are smoothed across shared vertices (see
<a HREF="concepts.html#4.6.3.5">4.6.3.5, Crease angle field</a>).</p>

<p>If the <i>texCoord</i> field is not NULL, it shall contain a <a HREF="nodesref.html#TextureCoordinate">TextureCoordinate</a> node. The texture coordinates
in that node are applied to the vertices of the IndexedFaceSet as follows:</p>

<p><!--NOEDIT--><ol START="6" TYPE="a">
  <li>If the <i>texCoordIndex</i> field is not empty, then it is used to
  choose texture coordinates for each vertex of the IndexedFaceSet in exactly
  the same manner that the <i>coordIndex</i> field is used to choose coordinates
  for each vertex from the Coordinate node. The <i>texCoordIndex</i> field
  shall contain at least as many indices as the <i>coordIndex</i> field,
  and shall contain end-of-face markers (-1) in exactly the same places as
  the <i>coordIndex</i> field. If the greatest index in the <i>texCoordIndex</i>
  field is N, then there shall be N+1 texture coordinates in the TextureCoordinate
  node.
  <li>If the <i>texCoordIndex</i> field is empty, then the <i>coordIndex</i>
  array is used to choose texture coordinates from the TextureCoordinate
  node. If the greatest index in the <i>coordIndex</i> field is N, then there
  shall be N+1 texture coordinates in the TextureCoordinate node.
</ol><!--/NOEDIT--></p>

<p>If the <i>texCoord</i> field is NULL, a default texture coordinate mapping
is calculated using the local coordinate system bounding box of the shape.
The longest dimension of the bounding box defines the S coordinates, and
the next longest defines the T coordinates. If two or all three dimensions
of the bounding box are equal, ties shall be broken by choosing the X, Y,
or Z dimension in that order of preference. The value of the S coordinate
ranges from 0 to 1, from one end of the bounding box to the other. The T
coordinate ranges between 0 and the ratio of the second greatest dimension
of the bounding box to the greatest dimension. <a HREF="nodesref.html#Figure6.10">Figure
6.10</a> illustrates the default texture coordinates for a simple box shaped
IndexedFaceSet with an X dimension twice as large as the Z dimension and
four times as large as the Y dimension. <a HREF="nodesref.html#Figure6.11">Figure&nbsp;6.11</a>
illustrates the original texture image used on the IndexedFaceSet used in
<a HREF="nodesref.html#Figure6.10">Figure 6.10</a>.</p>

<h4><center><a NAME="Figure6.10"></a><img SRC="../Images/IFStexture.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/IFStexture.gif" WIDTH="488" HEIGHT="352" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="IndexedFaceSet node texture mapping"><br>
Figure 6.10 -- IndexedFaceSet texture default mapping<br>
<br>
<br>
</center></h4>

<h4><center><a NAME="Figure6.11"></a><img SRC="../Images/IFStexture2.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/IFStexture2.gif" WIDTH="362" HEIGHT="171" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="ImageTexture for IndexedFaceSet in Figure 6.10"><br>
Figure 6.11 -- ImageTexture for IndexedFaceSet in Figure 6.10<br>
<br>
</center></h4>

<p>Subclause <a HREF="concepts.html#4.6.3">4.6.3, Shapes and geometry</a>,
provides a description of the <i>ccw</i>, <i>solid</i>, <i>convex</i>, and
<i>creaseAngle</i> fields.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="IndexedLineSet"></a>6.24 IndexedLineSet</h2>

<pre>
<b>IndexedLineSet { </b>
  eventIn       MFInt32 set_colorIndex
  eventIn       MFInt32 set_coordIndex
  exposedField  SFNode  <b>color             NULL</b>
  exposedField  SFNode  <b>coord             NULL</b>
  field         MFInt32<b> colorIndex        []</b>     # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field         SFBool  <b>colorPerVertex    TRUE</b>
  field         MFInt32<b> coordIndex        []</b>     # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The IndexedLineSet node represents a 3D geometry formed by constructing
polylines from 3D vertices specified in the <i>coord</i> field. IndexedLineSet
uses the indices in its <i>coordIndex</i> field to specify the polylines
by connecting vertices from the <i>coord</i> field. An index of &quot;-1&quot;
indicates that the current polyline has ended and the next one begins. The
last polyline may be (but does not have to be) followed by a &quot;-1&quot;.
IndexedLineSet is specified in the local coordinate system and is affected
by the transformations of its ancestors.</p>

<p>The <i>coord</i> field specifies the 3D vertices of the line set and
contains a <a HREF="nodesref.html#Coordinate">Coordinate</a> node.</p>

<p>Lines are not lit, are not texture-mapped, and do not participate in
collision detection. The width of lines is implementation dependent and
each line segment is solid (i.e.,&nbsp;not dashed).</p>

<p>If the <i>color</i> field is not NULL, it shall contain a Color node.
The colours are applied to the line(s) as follows:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>If <i>colorPerVertex</i> is FALSE:
  <ol START="1" TYPE="1">
    <li>If the <i>colorIndex</i> field is not empty, one colour is used
    for each polyline of the IndexedLineSet. There shall be at least as many
    indices in the <i>colorIndex</i> field as there are polylines in the IndexedLineSet.
    If the greatest index in the <i>colorIndex</i> field is N, there shall
    be N+1 colours in the Color node. The <i>colorIndex</i> field shall not
    contain any negative entries.
    <li>If the <i>colorIndex</i> field is empty, the colours from the
    Color node are applied to each polyline of the IndexedLineSet in order.
    There shall be at least as many colours in the Color node as there are
    polylines.
  </ol>
  <li>If <i>colorPerVertex</i> is TRUE:
  <ol START="1" TYPE="1">
    <li>If the <i>colorIndex</i> field is not empty, colours are applied
    to each vertex of the IndexedLineSet in exactly the same manner that the
    <i>coordIndex</i> field is used to supply coordinates for each vertex from
    the Coordinate node. The <i>colorIndex</i> field shall contain at least
    as many indices as the <i>coordIndex</i> field and shall contain end-of-polyline
    markers (-1) in exactly the same places as the <i>coordIndex</i> field.
    If the greatest index in the <i>colorIndex</i> field is N, there shall
    be N+1 colours in the Color node.
    <li>If the <i>colorIndex</i> field is empty, the <i>coordIndex</i>
    field is used to choose colours from the Color node. If the greatest index
    in the <i>coordIndex</i> field is N, there shall be N+1 colours in
    the Color node.
  </ol>
</ol><!--/NOEDIT--></p>

<p>If the <i>color</i> field is NULL and there is a Material defined for
the Appearance affecting this IndexedLineSet, the <i>emissiveColor</i> of
the Material shall be used to draw the lines. Details on lighting equations
as they affect IndexedLineSet nodes are described in <a HREF="concepts.html#4.14">4.14,
Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Inline"></a>6.25 Inline</h2>

<pre>
<b>Inline { </b>
  exposedField MFString <b>url        []</b>
  field        SFVec3f  <b>bboxCenter 0 0 0     </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f  <b>bboxSize   -1 -1 -1  </b>#&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)&nbsp;or&nbsp;-1,-1,-1
<b>}</b></pre>

<p>The Inline node is a grouping node that reads its children data from
a location in the World Wide Web. Exactly when its children are read and
displayed is not defined (e.g.&nbsp;reading the children may be delayed
until the Inline node's bounding box is visible to the viewer). The <i>url</i>
field specifies the URL containing the children. An Inline node with an
empty URL does nothing.</p>

<p>Each specified URL shall refer to a valid VRML file that contains a list
of children nodes, prototypes, and routes at the top level as described
in <a HREF="concepts.html#4.6.5">4.6.5, Grouping and children nodes</a>.
The results are undefined if the URL refers to a file that is not VRML or
if the VRML file contains non-children nodes at the top level.</p>

<p>If multiple URLs are specified, the browser may display a URL of a lower
preference VRML file while it is obtaining, or if it is unable to obtain,
the higher preference VRML file. Details on the <i>url</i> field and preference
order can be found in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p>The results are undefined if the contents of the URL change after it
has been loaded.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the Inline node's children. This is a hint that may be used
for optimization purposes. The results are undefined if the specified bounding
box is smaller than the actual bounding box of the children at any time.
A default <i>bboxSize</i> value, (-1,&nbsp;-1,&nbsp;-1), implies that the
bounding box is not specified and if needed shall be calculated by the browser.
A description of the <i>bboxCenter</i> and <i>bboxSize</i> fields is in
<a HREF="concepts.html#4.6.4">4.6.4,&nbsp;Bounding&nbsp;boxes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="LOD"></a>6.26 LOD</h2>

<pre>
<b>LOD { </b>
  exposedField MFNode  <b>level    []</b> 
  field        SFVec3f <b>center   0 0 0    </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        MFFloat <b>range    []       </b>#&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The LOD node specifies various levels of detail or complexity for a given
object, and provides hints allowing browsers to automatically choose the
appropriate version of the object based on the distance from the user. The
<i>level</i> field contains a list of nodes that represent the same object
or objects at varying levels of detail, ordered from highest level of detail
to the lowest level of detail. The <i>range</i> field specifies the ideal
distances at which to switch between the levels. Subclause <a HREF="concepts.html#4.6.5">4.6.5,&nbsp;Grouping&nbsp;and&nbsp;children&nbsp;nodes</a>,
contains details on the types of nodes that are legal values for <i>level</i>.</p>

<p>The <i>center</i> field is a translation offset in the local coordinate
system that specifies the centre of the LOD node for distance calculations.</p>

<p>The number of nodes in the <i>level</i> field shall exceed the number
of values in the <i>range</i> field by one (i.e.,&nbsp;N+1 <i>level</i>
values for N <i>range</i> values). The <i>range</i> field contains monotonic
increasing values that shall be greater than zero. In order to calculate
which level to display, first the distance is calculated from the viewer's
location, transformed into the local coordinate system of the LOD node (including
any scaling transformations), to the <i>center</i> point of the LOD node.
Then, the LOD node evaluates the step function <i>L(d)</i> to choose a level
for a given value of <i>d</i> (where <i>d</i> is the distance from the viewer
position to the centre of the LOD node).</p>

<p>Let <i>n</i> ranges, <i>R</i><sub><i>0</i></sub>, <i>R</i><sub><i>1</i></sub>,
<i>R</i><sub><i>2</i></sub>, ..., <i>R</i><sub><i>n</i>-1</sub>, partition
the domain (0,&nbsp;+<i>infinity</i>) into <i>n</i>+1 subintervals given
by (0,&nbsp;<i>R</i><sub><i>0</i></sub>), [<i>R</i><sub><i>0</i></sub>,&nbsp;<i>R</i><sub><i>1</i></sub>)...
, [<i>R</i><sub><i>n</i>-1</sub>,&nbsp;+<i>infinity</i>). Also, let <i>n</i>
levels <i>L</i><sub><i>0</i></sub>,<i> L</i><sub><i>1</i></sub>, <i>L</i><sub><i>2</i></sub>,
..., <i>L</i><sub><i>n</i>-1</sub> be the values of the step function function
<i>L(d)</i>. The level node, <i>L(d),</i> for a given distance <i>d</i>
is defined as follows:</p>

<pre>
    L(d) = L<sub>0</sub>,   if d &lt; R<sub>0</sub>,
         = L<sub>i+1</sub>, if R<sub>i</sub> &lt;= d &lt; R<sub>i+1</sub>, for -1&nbsp;&lt;&nbsp;i &lt;&nbsp;n-1,
         = L<sub>n-1</sub>, if d &gt;= R<sub>n-1</sub>.</pre>

<p>Specifying too few levels will result in the last level being used repeatedly
for the lowest levels of detail. If more levels than ranges are specified,
the extra levels are ignored. An empty range field is an exception to this
rule. This case is a hint to the browser that it may choose a level automatically
to maintain a constant display rate. Each value in the <i>range</i> field
shall be greater than the previous value.</p>

<p>LOD nodes are evaluated top-down in the scene graph. Only the descendants
of the currently selected level are rendered. All nodes under an LOD node
continue to receive and send events regardless of which LOD node's <i>level</i>
is active. For example, if an active TimeSensor node is contained within
an inactive level of an LOD node, the TimeSensor node sends events regardless
of the LOD node's state.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Material"></a>6.27 Material</h2>

<pre>
<b>Material { </b>
  exposedField SFFloat <b>ambientIntensity  0.2         </b>#&nbsp;[0,1]
  exposedField SFColor <b>diffuseColor      0.8 0.8 0.8 </b>#&nbsp;[0,1]
  exposedField SFColor <b>emissiveColor     0 0 0       </b>#&nbsp;[0,1]
  exposedField SFFloat <b>shininess         0.2         </b>#&nbsp;[0,1]
  exposedField SFColor <b>specularColor     0 0 0       </b>#&nbsp;[0,1]
  exposedField SFFloat <b>transparency      0           </b>#&nbsp;[0,1]
<b>}</b></pre>

<p>The Material node specifies surface material properties for associated
geometry nodes and is used by the VRML lighting equations during rendering.
Subclause <a HREF="concepts.html#4.14">4.14, Lighting model</a>, contains
a detailed description of the VRML lighting model equations.</p>

<p>All of the fields in the Material node range from 0.0 to 1.0.</p>

<p>The fields in the Material node determine how light reflects off an object
to create colour:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>The <i>ambientIntensity</i> field specifies how much ambient light
  from light sources this surface shall reflect. Ambient light is omnidirectional
  and depends only on the number of light sources, not their positions with
  respect to the surface. Ambient colour is calculated as <i>ambientIntensity&nbsp;</i>×&nbsp;<i>diffuseColor</i>.
  <li>The <i>diffuseColor</i> field reflects all VRML light sources depending
  on the angle of the surface with respect to the light source. The more
  directly the surface faces the light, the more diffuse light reflects.
  <li>The <i>emissiveColor</i> field models &quot;glowing&quot; objects.
  This can be useful for displaying pre-lit models (where the light energy
  of the room is computed explicitly), or for displaying scientific data.
  <li>The <i>specularColor</i> and <i>shininess</i> fields determine the
  specular highlights (e.g.,&nbsp;the shiny spots on an apple). When the
  angle from the light to the surface is close to the angle from the surface
  to the viewer, the <i>specularColor</i> is added to the diffuse and ambient
  colour calculations. Lower shininess values produce soft glows, while higher
  values result in sharper, smaller highlights.
  <li>The <i>transparency </i>field specifies how &quot;clear&quot; an object
  is, with 1.0 being completely transparent, and 0.0 completely opaque.
</ol><!--/NOEDIT--></p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="MovieTexture"></a>6.28 MovieTexture</h2>

<pre>
<b>MovieTexture { </b>
  exposedField SFBool   <b>loop</b>             <b>FALSE</b>
  exposedField SFFloat  <b>speed</b>            <b>1.0      </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFTime   <b>startTime</b>        <b>0        </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFTime   <b>stopTime</b>         <b>0        </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFString <b>url</b>              <b>[]</b>
  field        SFBool   <b>repeatS          TRUE</b>
  field        SFBool   <b>repeatT          TRUE</b>
  eventOut     SFTime   duration_changed
  eventOut     SFBool   isActive
<b>}</b></pre>

<p>The MovieTexture node defines a time dependent texture map (contained
in a movie file) and parameters for controlling the movie and the texture
mapping. A MovieTexture node can also be used as the source of sound data
for a <a HREF="nodesref.html#Sound">Sound</a> node. In this special case, the MovieTexture
node is not used for rendering.</p>

<p>Texture maps are defined in a 2D coordinate system (s,&nbsp;t) that ranges
from 0.0 to 1.0 in both directions. The bottom edge of the image corresponds
to the S-axis of the texture map, and left edge of the image corresponds
to the T-axis of the texture map. The lower-left pixel of the image corresponds
to s=0.0, t=0.0, and the top-right pixel of the image corresponds to s=1.0,
t=1.0. <a HREF="nodesref.html#Figure6.12">Figure 6.12</a> depicts the texture map coordinate
system of the MovieTexture.</p>

<p><center><a NAME="Figure6.12"></a><img SRC="../Images/ImageTexture.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/ImageTexture.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED WIDTH="413" HEIGHT="228" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="MovieTexture node"></center></p>

<h4><center>Figure 6.12 -- MovieTexture node coordinate system</center></h4>

<p>The <i>url</i> field that defines the movie data shall support MPEG1-Systems
(audio and video) or MPEG1-Video (video-only) movie file formats <a HREF="references.html#[MPEG]">2.[MPEG]</a>. Details on the <i>url</i> field can
be found in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p>MovieTexture nodes can be referenced by an Appearance node's <i>texture</i>
field (as a movie texture) and by a Sound node's <i>source</i> field (as
an audio source only).</p>

<p>See <a HREF="concepts.html#4.6.11">4.6.11, Texture maps</a>, for a general
description of texture maps.</p>

<p><a HREF="concepts.html#4.14">4.14, Lighting model</a>, contains details
on lighting equations and the interaction between textures, materials, and
geometries.</p>

<p>As soon as the movie is loaded, a <i>duration_changed</i> eventOut is
sent. This indicates the duration of the movie in seconds. This eventOut
value can be read (for instance, by a Script node) to determine the duration
of a movie. A value of &quot;-1&quot; implies the movie has not yet loaded
or the value is unavailable for some reason.</p>

<p>The <i>loop, startTime,</i> and <i>stopTime</i> exposedFields and the
<i>isActive</i> eventOut, and their effects on the MovieTexture node, are
discussed in detail in the <a HREF="concepts.html#4.6.9">4.6.9,&nbsp;Time-dependent
nodes</a>, section. The cycle<i> </i>of a MovieTexture node is the length
of time in seconds for one playing of the movie at the specified <i>speed</i>.</p>

<p>The <i>speed</i> exposedField indicates how fast the movie shall be played.
A <i>speed</i> of 2 indicates the movie plays twice as fast. The <i>duration_changed</i>
output is not affected by the <i>speed</i> exposedField. <i>set_speed</i>
events are ignored while the movie is playing. A negative <i>speed</i> implies
that the movie will play backwards.</p>

<p>If a MovieTexture node is inactive when the movie is first loaded, frame
0 of the movie texture is displayed if <i>speed</i> is non-negative or the
last frame of the movie texture is shown if <i>speed</i> is negative (see
<a HREF="concepts.html#4.11.3">4.11.3, Discrete and continuous changes</a>).
A MovieTexture node shall display frame 0 if <i>speed</i> = 0. For positive
values of <i>speed</i>, an active MovieTexture node displays the frame at
movie time <i>t</i> as follows (i.e.,&nbsp;in the movie's local time system
with frame 0 at time 0 with <i>speed</i> = 1):</p>

<pre>
    t = (now - startTime) modulo (<tt>duration</tt>/speed)</pre>

<p>If <i>speed</i> is negative, the MovieTexture node displays the frame
at movie time:</p>

<pre>
<tt>    t = duration</tt> - ((now - startTime) modulo |<tt>duration</tt>/speed|)</pre>

<p>When a MovieTexture node becomes inactive, the frame corresponding to
the time at which the MovieTexture became inactive will remain as the texture.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="NavigationInfo"></a>6.29 NavigationInfo</h2>

<pre>
<b>NavigationInfo { </b>
  eventIn      SFBool   set_bind
  exposedField MFFloat <b> avatarSize      [0.25, 1.6, 0.75] </b>#&nbsp;[0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool   <b>headlight       TRUE</b>
  exposedField SFFloat  <b>speed           1.0</b>               #&nbsp;[0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFString<b> type            [&quot;WALK&quot;, &quot;ANY&quot;]</b>
  exposedField SFFloat  <b>visibilityLimit 0.0               </b>#&nbsp;[0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFBool   isBound
<b>}</b></pre>

<p>The NavigationInfo node contains information describing the physical
characteristics of the viewer's avatar and viewing model. NavigationInfo
node is a bindable node (see <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable&nbsp;children&nbsp;nodes</a><i>)</i>.
Thus, there exists a NavigationInfo node stack in which the top-most NavigationInfo
node on the stack is the currently bound NavigationInfo node. The current
NavigationInfo node is considered to be a child of the current Viewpoint
node regardless of where it is initially located in the VRML file. Whenever
the current Viewpoint nodes changes, the current NavigationInfo node shall
be re-parented to it by the browser. Whenever the current NavigationInfo
node changes, the new NavigationInfo node shall be re-parented to the current
Viewpoint node by the browser.</p>

<p>If a TRUE value is sent to the <i>set_bind</i> eventIn of a NavigationInfo
node, the node is pushed onto the top of the NavigationInfo node stack.
When a NavigationInfo node is bound, the browser uses the fields of the
NavigationInfo node to set the navigation controls of its user interface
and the NavigationInfo node is conceptually re-parented under the currently
bound Viewpoint node. All subsequent scaling changes to the current <a HREF="nodesref.html#Viewpoint">Viewpoint</a> node's coordinate system automatically change
aspects (see below) of the NavigationInfo node values used in the browser
(e.g.,&nbsp;scale changes to any ancestors' transformations). A FALSE value
sent to <i>set_bind</i> pops the NavigationInfo node from the stack, results
in an <i>isBound </i>FALSE event, and pops to the next entry in the stack
which shall be re-parented to the current Viewpoint node. <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable
children nodes</a>, has more details on binding stacks.</p>

<p>The <i>type</i> field specifies an ordered list of navigation paradigms
that specify a combination of navigation types and the initial navigation
type. The navigation type of the currently bound NavigationInfo node determines
the user interface capabilities of the browser. For example, if the currently
bound NavigationInfo node's <i>type</i> is &quot;WALK&quot;, the browser
shall present a WALK navigation user interface paradigm (see below for description
of WALK). Browsers shall recognize and support at least the following navigation
types: &quot;ANY&quot;, &quot;WALK&quot;, &quot;EXAMINE&quot;, &quot;FLY&quot;,
and &quot;NONE&quot;.</p>

<p>If &quot;ANY&quot; does not appear in the <i>type</i> field list of the
currently bound NavigationInfo, the browser's navigation user interface
shall be restricted to the recognized navigation types specified in the
list. In this case, browsers shall not present a user interface that allows
the navigation type to be changed to a type not specified in the list. However,
if any one of the values in the <i>type</i> field are &quot;ANY&quot;, the
browser may provide any type of navigation interface, and allow the user
to change the navigation type dynamically. Furthermore, the first recognized
type in the list shall be the initial navigation type presented by the browser's
user interface.</p>

<p>ANY navigation specifies that the browser may choose the navigation paradigm
that best suits the content and provide a user interface to allow the user
to change the navigation paradigm dynamically. The results are undefined
if the currently bound NavigationInfo's <i>type</i> value is &quot;ANY&quot;
and Viewpoint transitions (see <a HREF="nodesref.html#Viewpoint">6.53,&nbsp;Viewpoint</a>)
are triggered by the Anchor node (see <a HREF="nodesref.html#Anchor">6.2,&nbsp;Anchor</a>)
or the <tt>loadURL()</tt>scripting method (see <a HREF="concepts.html#4.12.10">4.12.10,&nbsp;Browser&nbsp;script&nbsp;interface</a>).</p>

<p>WALK navigation is used for exploring a virtual world on foot or in a
vehicle that rests on or hovers above the ground. It is strongly recommended
that WALK navigation define the up vector in the +Y direction and provide
some form of terrain following and gravity in order to produce a walking
or driving experience. If the bound NavigationInfo's <i>type</i> is &quot;WALK&quot;,
the browser shall strictly support collision detection (see <a HREF="nodesref.html#Collision">6.8,&nbsp;Collision</a>).</p>

<p>FLY navigation is similar to WALK except that terrain following and gravity
may be disabled or ignored. There shall still be some notion of &quot;up&quot;
however. If the bound NavigationInfo's <i>type</i> is &quot;FLY&quot;, the
browser shall strictly support collision detection (see <a HREF="nodesref.html#Collision">6.8,&nbsp;Collision</a>).</p>

<p>EXAMINE navigation is used for viewing individual objects and often includes
(but does not require) the ability to spin around the object and move the
viewer closer or further away.</p>

<p>NONE navigation disables and removes all browser-specific navigation
user interface forcing the user to navigate using only mechanisms provided
in the scene, such as Anchor nodes or scripts that include <tt>loadURL()</tt>.</p>

<p>If the NavigationInfo type is &quot;WALK&quot;, &quot;FLY&quot;, &quot;EXAMINE&quot;,
or &quot;NONE&quot; or a combination of these types (i.e., &quot;ANY&quot;
is not in the list), Viewpoint transitions (see <a HREF="nodesref.html#Viewpoint">6.53,&nbsp;Viewpoint</a>)
triggered by the Anchor node (see <a HREF="nodesref.html#Anchor">6.2,&nbsp;Anchor</a>)
or the <tt>loadURL()</tt>scripting method (see&nbsp;<a HREF="concepts.html#4.12.10">4.12.10,&nbsp;Browser&nbsp;script&nbsp;interface</a>)
shall be implemented as a jump cut from the old Viewpoint to the new Viewpoint
with transition effects that shall not trigger events besides the exit and
enter events caused by the jump.</p>

<p>Browsers may create browser-specific navigation type extensions. It is
recommended that extended <i>type</i> names include a unique suffix (e.g.,&nbsp;HELICOPTER_mydomain.com)
to prevent conflicts. Viewpoint transitions (see <a HREF="nodesref.html#Viewpoint">6.53,&nbsp;Viewpoint</a>)
triggered by the Anchor node (see&nbsp;<a HREF="nodesref.html#Anchor">6.2,&nbsp;Anchor</a>)
or the <tt>loadURL()</tt>scripting method (see <a HREF="concepts.html#4.12.10">4.12.10,&nbsp;Browser&nbsp;script&nbsp;interface</a>)
are undefined for extended navigation types. If none of the types are recognized
by the browser, the default &quot;ANY&quot; is used. These strings values
are case sensitive (&quot;any&quot; is not equal to &quot;ANY&quot;).</p>

<p>The <i>speed</i> field specifies the rate at which the viewer travels
through a scene in metres per second. Since browsers may provide mechanisms
to travel faster or slower, this field specifies the default, average speed
of the viewer when the NavigationInfo node is bound. If the NavigationInfo
<i>type</i> is EXAMINE, <i>speed</i> shall not affect the viewer's rotational
speed. Scaling in the transformation hierarchy of the currently bound <a HREF="nodesref.html#Viewpoint">Viewpoint</a> node (see above) scales the <i>speed</i>;
parent translation and rotation transformations have no effect on <i>speed</i>.
Speed shall be non-negative. Zero speed indicates that the avatar's position
is stationary, but its orientation and field of view may still change. If
the navigation <i>type</i> is &quot;NONE&quot;, the <i>speed</i> field has
no effect.</p>

<p>The <i>avatarSize</i> field specifies the user's physical dimensions
in the world for the purpose of collision detection and terrain following.
It is a multi-value field allowing several dimensions to be specified. The
first value shall be the allowable distance between the user's position
and any collision geometry (as specified by a <a HREF="nodesref.html#Collision">Collision</a>
node ) before a collision is detected. The second shall be the height above
the terrain at which the browser shall maintain the viewer. The third shall
be the height of the tallest object over which the viewer can move. This
allows staircases to be built with dimensions that can be ascended by viewers
in all browsers. The transformation hierarchy of the currently bound <a HREF="nodesref.html#Viewpoint">Viewpoint</a> node scales the <i>avatarSize</i>. Translations
and rotations have no effect on <i>avatarSize</i>.</p>

<p>For purposes of terrain following, the browser maintains a notion of
the <i>down</i> direction (down vector), since gravity is applied in the
direction of the down vector. This down vector shall be along the negative
Y-axis in the local coordinate system of the currently bound Viewpoint node
(i.e.,&nbsp;the accumulation of the Viewpoint node's ancestors' transformations,
not including the Viewpoint node's <i>orientation</i> field).</p>

<p>Geometry beyond the visibilityLimit may not be rendered. A value of 0.0
indicates an infinite visibility limit. The <i>visibilityLimit</i> field
is restricted to be greater than or equal to zero.</p>

<p>The <i>speed</i>, <i>avatarSize</i> and <i>visibilityLimit</i> values
are all scaled by the transformation being applied to the currently bound
<a HREF="nodesref.html#Viewpoint">Viewpoint</a> node. If there is no currently bound
Viewpoint node, the values are interpreted in the world coordinate system.
This allows these values to be automatically adjusted when binding to a
Viewpoint node that has a scaling transformation applied to it without requiring
a new NavigationInfo node to be bound as well. The results are undefined
if the scale applied to the Viewpoint node is non-uniform.</p>

<p>The <i>headlight</i> field specifies whether a browser shall turn on
a headlight. A headlight is a directional light that always points in the
direction the user is looking. Setting this field to TRUE allows the browser
to provide a headlight, possibly with user interface controls to turn it
on and off. Scenes that enlist precomputed lighting (e.g.,&nbsp;radiosity
solutions) can turn the headlight off. The headlight shall have <i>intensity&nbsp;</i>=&nbsp;1,
<i>color</i> =&nbsp;(1&nbsp;1&nbsp;1), <i>ambientIntensity&nbsp;</i>=&nbsp;0.0,
and <i>direction&nbsp;</i>=&nbsp;(0&nbsp;0&nbsp;-1).</p>

<p>It is recommended that the near clipping plane be set to one-half of
the collision radius as specified in the <i>avatarSize</i> field (setting
the near plane to this value prevents excessive clipping of objects just
above the collision volume, and also provides a region inside the collision
volume for content authors to include geometry intended to remain fixed
relative to the viewer). Such geometry shall not be occluded by geometry
outside of the collision volume.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Normal"></a>6.30 Normal</h2>

<pre>
<b>Normal { </b>
  exposedField MFVec3f <b>vector  []   </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>This node defines a set of 3D surface normal vectors to be used in the
<i>vector</i> field of some geometry nodes (e.g.,&nbsp;IndexedFaceSet and
ElevationGrid). This node contains one multiple-valued field that contains
the normal vectors. Normals shall be of unit length.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="NormalInterpolator"></a>6.31 NormalInterpolator</h2>

<pre>
<b>NormalInterpolator { </b>
  eventIn      SFFloat set_fraction       #&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>key           []   </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFVec3f <b>keyValue</b> <b>     []   </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     MFVec3f value_changed
<b>}</b></pre>

<p>The NormalInterpolator node interpolates among a list of normal vector
sets specified by the <i>keyValue</i> field. The output vector, <i>value_changed</i>,
shall be a set of normalized vectors.</p>

<p>Values in the <i>keyValue</i> field shall be of unit length. The number
of normals in the <i>keyValue</i> field shall be an integer multiple of
the number of keyframes in the <i>key</i> field. That integer multiple defines
how many normals will be contained in the <i>value_changed </i>events.</p>

<p>Normal interpolation shall be performed on the surface of the unit sphere.
That is, the output values for a linear interpolation from a point P on
the unit sphere to a point Q also on the unit sphere shall lie along the
shortest arc (on the unit sphere) connecting points P and Q. Also, equally
spaced input fractions shall result in arcs of equal length. The results
are undefined if P and Q are diagonally opposite.</p>

<p>A more detailed discussion of interpolators is provided in <a HREF="concepts.html#4.6.8">4.6.8,
Interpolator nodes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="OrientationInterpolator"></a>6.32 OrientationInterpolator</h2>

<pre>
<b>OrientationInterpolator { </b>
  eventIn      SFFloat    set_fraction      #&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat    <b>key           []  </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFRotation <b>keyValue      []  </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFRotation value_changed
<b>}</b></pre>

<p>The OrientationInterpolator node interpolates among a list of rotation
values specified in the <i>keyValue</i> field. These rotations are absolute
in object space and therefore are not cumulative. The <i>keyValue</i> field
shall contain exactly as many rotations as there are keyframes in the <i>key</i>
field.</p>

<p>An orientation represents the final position of an object after a rotation
has been applied. An OrientationInterpolator interpolates between two orientations
by computing the shortest path on the unit sphere between the two orientations.
The interpolation is linear in arc length along this path. The results are
undefined if the two orientations are diagonally opposite.</p>

<p>If two consecutive <i>keyValue </i>values exist such that the arc length
between them is greater than <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">, the interpolation will take place on the arc
complement. For example, the interpolation between the orientations (0,
1, 0, 0) and (0, 1, 0, 5.0) is equivalent to the rotation between the orientations
(0, 1, 0, 2<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">) and (0, 1, 0, 5.0).</p>

<p>A more detailed discussion of interpolators is contained in <a HREF="concepts.html#4.6.8">4.6.8, Interpolator nodes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="PixelTexture"></a>6.33 PixelTexture</h2>

<pre>
<b>PixelTexture { </b>
<b>  </b>exposedField SFImage  <b>image      0 0 0    </b># see <a HREF="fieldsRef.html#SFImage">5.5, SFImage</a>
<b> </b> field        SFBool   <b>repeatS    TRUE</b>
<b>  </b>field        SFBool   <b>repeatT    TRUE</b>
<b>}</b></pre>

<p>The PixelTexture node defines a 2D image-based texture map as an explicit
array of pixel values (<i>image</i> field) and parameters controlling tiling
repetition of the texture onto geometry.</p>

<p>Texture maps are defined in a 2D coordinate system (s,&nbsp;t) that ranges
from 0.0 to 1.0 in both directions. The bottom edge of the pixel image corresponds
to the S-axis of the texture map, and left edge of the pixel image corresponds
to the T-axis of the texture map. The lower-left pixel of the pixel image
corresponds to s=0.0, t=0.0, and the top-right pixel of the image corresponds
to s&nbsp;=&nbsp;1.0, t&nbsp;=&nbsp;1.0.</p>

<p>See <a HREF="concepts.html#4.6.11">4.6.11, Texture maps</a>, for a general
description of texture maps. <a HREF="nodesref.html#Figure6.13">Figure 6.13</a> depicts
an example PixelTexture.</p>

<h4><center><a NAME="Figure6.13"></a><img SRC="../Images/ImageTexture.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/ImageTexture.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED WIDTH="413" HEIGHT="228" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="PixelTexture node"><br>
Figure 6.13 -- PixelTexture node<br>
</center></h4>

<p>See <a HREF="concepts.html#4.14">4.14 ,Lighting model</a>, for a description
of how the texture values interact with the appearance of the geometry.
<a HREF="fieldsRef.html#SFImage">5.5, SFImage</a>, describes the specification
of an image.</p>

<p>The <i>repeatS</i> and <i>repeatT</i> fields specify how the texture
wraps in the S and T directions. If <i>repeatS</i> is TRUE (the default),
the texture map is repeated outside the 0-to-1 texture coordinate range
in the S direction so that it fills the shape. If <i>repeatS</i> is FALSE,
the texture coordinates are clamped in the S direction to lie within the
0.0 to 1.0 range. The <i>repeatT</i> field is analogous to the <i>repeatS</i>
field.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="PlaneSensor"></a>6.34 PlaneSensor</h2>

<pre>
<b>PlaneSensor { </b>
  exposedField SFBool  <b>autoOffset</b>          <b>TRUE</b>
  exposedField SFBool  <b>enabled             TRUE</b>
  exposedField SFVec2f<b> maxPosition         -1 -1     </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec2f<b> minPosition         0 0       </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec3f <b>offset</b>              <b>0 0 0     </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFBool  isActive
  eventOut     SFVec3f trackPoint_changed
  eventOut     SFVec3f translation_changed
<b>}</b></pre>

<p>The PlaneSensor node maps pointing device motion into two-dimensional
translation in a plane parallel to the Z=0 plane of the local coordinate
system. The PlaneSensor node uses the descendent geometry of its parent
node to determine whether it is liable to generate events.</p>

<p>The <i>enabled</i> exposedField enables and disables the PlaneSensor.
If <i>enabled</i> is TRUE, the sensor reacts appropriately to user events.
If <i>enabled</i> is FALSE, the sensor does not track user input or send
events. If <i>enabled</i> receives a FALSE event and <i>isActive</i> is
TRUE, the sensor becomes disabled and deactivated, and outputs an <i>isActive</i>
FALSE event. If <i>enabled</i> receives a TRUE event, the sensor is enabled
and made ready for user activation.</p>

<p>The PlaneSensor node generates events when the pointing device is activated
while the pointer is indicating any descendent geometry nodes of the sensor's
parent group. See <a HREF="concepts.html#4.6.7.5">4.6.7.5, Activating and
manipulating sensors</a>, for details on using the pointing device to activate
the PlaneSensor.</p>

<p>Upon activation of the pointing device (e.g.,&nbsp;mouse button down)
while indicating the sensor's geometry, an <i>isActive</i> TRUE event is
sent. Pointer motion is mapped into relative translation in the <i>tracking
plane</i>, (a plane parallel to the sensor's local Z=0 plane and coincident
with the initial point of intersection). For each subsequent movement of
the bearing, a <i>translation_changed</i> event is output which corresponds
to the sum of the relative translation from the original intersection point
to the intersection point of the new bearing in the plane plus the <i>offset</i>
value. The sign of the translation is defined by the Z=0 plane of the sensor's
coordinate system. <i>trackPoint_changed</i> events reflect the unclamped
drag position on the surface of this plane. When the pointing device is
deactivated and <i>autoOffset</i> is TRUE, <i>offset</i> is set to the last
<i>translation_changed</i> value and an <i>offset_changed</i> event is generated.
More details are provided in <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>.</p>

<p>When the sensor generates an <i>isActive</i> TRUE event, it grabs all
further motion events from the pointing device until it is deactivated and
generates an <i>isActive</i> FALSE event. Other pointing-device sensors
shall not generate events during this time. Motion of the pointing device
while <i>isActive</i> is TRUE is referred to as a &quot;drag.&quot; If a
2D pointing device is in use, <i>isActive</i> events typically reflect the
state of the primary button associated with the device (i.e.,&nbsp;<i>isActive</i>
is TRUE when the primary button is pressed, and is FALSE when it is released).
If a 3D pointing device (e.g.,&nbsp;wand) is in use, <i>isActive</i> events
typically reflect whether the pointer is within or in contact with the sensor's
geometry.</p>

<p><i>minPosition</i> and <i>maxPosition</i> may be set to clamp <i>translation_changed</i>
events to a range of values as measured from the origin of the Z=0 plane.
If the X or Y component of <i>minPosition</i> is greater than the corresponding
component of <i>maxPosition</i>, <i>translation_changed</i> events are not
clamped in that dimension. If the X or Y component of <i>minPosition</i>
is equal to the corresponding component of <i>maxPosition</i>, that component
is constrained to the given value. This technique provides a way to implement
a line sensor that maps dragging motion into a translation in one dimension.</p>

<p>While the pointing device is activated and moved,<i> trackPoint_changed</i>
and <i>translation_changed</i> events are sent. <i>trackPoint_changed</i>
events represent the unclamped intersection points on the surface of the
tracking plane. If the pointing device is dragged off of the tracking plane
while activated (e.g.,&nbsp;above horizon line), browsers may interpret
this in a variety ways (e.g., clamp all values to the horizon). Each movement
of the pointing device, while <i>isActive</i> is TRUE, generates <i>trackPoint_changed</i>
and <i>translation_changed</i> events.</p>

<p>Further information about this behaviour can be found in <a HREF="concepts.html#4.6.7.3">4.6.7.3,
Pointing-device sensors</a>, <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>, and <a HREF="concepts.html#4.6.7.5">4.6.7.5, Activating and
manipulating sensors</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="PointLight"></a>6.35 PointLight</h2>

<pre>
<b>PointLight { </b>
  exposedField SFFloat <b>ambientIntensity  0</b>       # [0,1]
  exposedField SFVec3f <b>attenuation       1 0 0</b>   # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFColor <b>color             1 1 1 </b>  # [0,1]
  exposedField SFFloat <b>intensity         1</b>       # [0,1]
  exposedField SFVec3f <b>location          0 0 0</b>   # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool  <b>on                TRUE</b> 
  exposedField SFFloat <b>radius            100</b>     # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The PointLight node specifies a point light source at a 3D location in
the local coordinate system. A point light source emits light equally in
all directions; that is, it is omnidirectional. PointLight nodes are specified
in the local coordinate system and are affected by ancestor transformations.</p>

<p>Subclause <a HREF="concepts.html#4.6.6">4.6.6, Light sources</a>, contains
a detailed description of the <i>ambientIntensity</i>, <i>color</i>, and
<i>intensity</i> fields.</p>

<p>A PointLight node illuminates geometry within <i>radius</i> metres of
its <i>location</i>. Both radius and location are affected by ancestors'
transformations (scales affect <i>radius</i> and transformations affect
<i>location</i>). The <i>radius</i> field shall be greater than or equal
to zero.</p>

<p>PointLight node's illumination falls off with distance as specified by
three <i>attenuation</i> coefficients. The attenuation factor is <i>1/max(attenuation[0]&nbsp;+&nbsp;attenuation[1]</i>×<i>r&nbsp;+&nbsp;attenuation[2]</i>×<i>r</i><sup><i>2</i></sup><i>,&nbsp;1)</i>,
where <i>r</i> is the distance from the light to the surface being illuminated.
The default is no attenuation. An <i>attenuation</i> value of (0, 0, 0)
is identical to (1, 0, 0). Attenuation values shall be greater than or equal
to zero. A detailed description of VRML's lighting equations is contained
in <a HREF="concepts.html#4.14">4.14, Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="PointSet"></a>6.36 PointSet</h2>

<pre>
<b>PointSet { </b>
  exposedField  SFNode  <b>color      NULL</b>
  exposedField  SFNode  <b>coord      NULL</b>
<b>}</b></pre>

<p>The PointSet node specifies a set of 3D points, in the local coordinate
system, with associated colours at each point. The <i>coord</i> field specifies
a <a HREF="nodesref.html#Coordinate">Coordinate</a> node (or instance of a Coordinate
node). The results are undefined if the <i>coord</i> field specifies any
other type of node. PointSet uses the coordinates in order. If the <i>coord</i>
field is NULL, the point set is considered empty.</p>

<p>PointSet nodes are not lit, not texture-mapped, nor do they participate
in collision detection. The size of each point is implementation-dependent.</p>

<p>If the <i>color</i> field is not NULL, it shall specify a <a HREF="nodesref.html#Color">Color</a>
node that contains at least the number of points contained in the <i>coord</i>
node. The results are undefined if the <i>color</i> field specifies any
other type of node. Colours shall be applied to each point in order. The
results are undefined if the number of values in the Color node is less
than the number of values specified in the Coordinate node.</p>

<p>If the <i>color</i> field is NULL and there is a Material node defined
for the Appearance node affecting this PointSet node, the <i>emissiveColor</i>
of the Material node shall be used to draw the points. More details on lighting
equations can be found in <a HREF="concepts.html#4.14">4.14, Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="PositionInterpolator"></a>6.37 PositionInterpolator</h2>

<pre>
<b>PositionInterpolator { </b>
  eventIn      SFFloat set_fraction        # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>key           []    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFVec3f <b>keyValue      []    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFVec3f value_changed
<b>}</b></pre>

<p>The PositionInterpolator node linearly interpolates among a list of 3D
vectors. The <i>keyValue</i> field shall contain exactly as many values
as in the <i>key</i> field.</p>

<p><a HREF="concepts.html#4.6.8">4.6.8, Interpolator nodes</a>, contains
a more detailed discussion of interpolators.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="ProximitySensor"></a>6.38 ProximitySensor</h2>

<pre>
<b>ProximitySensor { </b>
  exposedField SFVec3f    <b>center      0 0 0    </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec3f    <b>size        0 0 0    </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool     <b>enabled     TRUE</b>
  eventOut     SFBool     isActive
  eventOut     SFVec3f    position_changed
  eventOut     SFRotation orientation_changed
  eventOut     SFTime     enterTime
  eventOut     SFTime     exitTime
<b>}</b></pre>

<p>The ProximitySensor node generates events when the viewer enters, exits,
and moves within a region in space (defined by a box). A proximity sensor
is enabled or disabled by sending it an <i>enabled</i> event with a value
of TRUE or FALSE. A disabled sensor does not send events.</p>

<p>A ProximitySensor node generates <i>isActive</i> TRUE/FALSE events as
the viewer enters and exits the rectangular box defined by its <i>center</i>
and <i>size</i> fields. Browsers shall interpolate viewer positions and
timestamp the <i>isActive</i> events with the exact time the viewer first
intersected the proximity region. The <i>center</i> field defines the centre
point of the proximity region in object space. The <i>size</i> field specifies
a vector which defines the width (x), height (y), and depth (z) of the box
bounding the region. The components of the <i>size</i> field shall be greater
than or equal to zero. ProximitySensor nodes are affected by the hierarchical
transformations of their parents.</p>

<p>The <i>enterTime</i> event is generated whenever the <i>isActive</i>
TRUE event is generated (user enters the box), and <i>exitTime</i> events
are generated whenever an <i>isActive</i> FALSE event is generated (user
exits the box).</p>

<p>The <i>position_changed</i> and <i>orientation_changed</i> eventOuts
send events whenever the user is contained within the proximity region and
the position and orientation of the viewer changes with respect to the ProximitySensor
node's coordinate system including enter and exit times. The viewer movement
may be a result of a variety of circumstances resulting from browser navigation,
ProximitySensor node's coordinate system changes, or bound Viewpoint node's
position or orientation changes.</p>

<p>Each ProximitySensor node behaves independently of all other ProximitySensor
nodes. Every enabled ProximitySensor node that is affected by the viewer's
movement receives and sends events, possibly resulting in multiple ProximitySensor
nodes receiving and sending events simultaneously. Unlike TouchSensor nodes,
there is no notion of a ProximitySensor node lower in the scene graph &quot;grabbing&quot;
events.</p>

<p>Instanced (DEF/USE) ProximitySensor nodes use the union of all the boxes
to check for enter and exit. A multiply instanced ProximitySensor node will
detect enter and exit for all instances of the box and send enter/exit events
appropriately. However, the results are undefined if the any of the boxes
of a multiply instanced ProximitySensor node overlap.</p>

<p>A ProximitySensor node that surrounds the entire world has an <i>enterTime</i>
equal to the time that the world was entered and can be used to start up
animations or behaviours as soon as a world is loaded. A ProximitySensor
node with a box containing zero volume (i.e., any <i>size</i> field element
of 0.0) cannot generate events. This is equivalent to setting the <i>enabled</i>
field to FALSE.</p>

<p>A ProximitySensor read from a VRML file shall generate <i>isActive </i>TRUE,
<i>position_changed</i>, <i>orientation_changed</i> and <i>enterTime</i>
events if the sensor is enabled and the viewer is inside the proximity region.
A ProximitySensor inserted into the transformation hierarchy shall generate
<i>isActive </i>TRUE, <i>position_changed</i>, <i>orientation_changed</i>
and <i>enterTime</i> events if the sensor is enabled and the viewer is inside
the proximity region. A ProximitySensor removed from the transformation
hierarchy shall generate <i>isActive </i>FALSE, <i>position_changed</i>,
<i>orientation_changed</i> and <i>exitTime</i> events if the sensor is enabled
and the viewer is inside the proximity region.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="ScalarInterpolator"></a>6.39 ScalarInterpolator</h2>

<pre>
<b>ScalarInterpolator { </b>
  eventIn      SFFloat set_fraction      <b>   </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>key           []     </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFFloat <b>keyValue      []     </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFFloat value_changed
<b>}</b></pre>

<p>This node linearly interpolates among a list of SFFloat values. This
interpolator is appropriate for any parameter defined using a single floating
point value. Examples include width, radius, and intensity fields. The <i>keyValue</i>
field shall contain exactly as many numbers as there are keyframes in the
<i>key</i> field.</p>

<p>A more detailed discussion of interpolators is available in <a HREF="concepts.html#4.6.8">4.6.8, Interpolator nodes</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Script"></a>6.40 Script</h2>

<pre>
<b>Script {</b> 
  exposedField MFString <b>url           []</b> 
  field        SFBool   <b>directOutput  FALSE</b>
  field        SFBool   <b>mustEvaluate  FALSE</b>
  # <i>And any number of</i>:
<b>  eventIn      eventType eventName</b>
<b>  field        fieldType fieldName initialValue</b>
<b>  eventOut     eventType eventName</b>
<b>}</b></pre>

<p>The Script node is used to program behaviour in a scene. Script nodes
typically</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>signify a change or user action;
  <li>receive events from other nodes;
  <li>contain a program module that performs some computation;
  <li>effect change somewhere else in the scene by sending events.
</ol><!--/NOEDIT--></p>

<p>Each Script node has associated programming language code, referenced
by the <i>url</i> field, that is executed to carry out the Script node's
function. That code is referred to as the &quot;script&quot; in the rest
of this description. Details on the <i>url</i> field can be found in <a HREF="concepts.html#4.5">4.5,&nbsp;VRML&nbsp;and&nbsp;the&nbsp;World&nbsp;Wide&nbsp;Web</a>.</p>

<p>Browsers are not required to support any specific language. Detailed
information on scripting languages is described in <a HREF="concepts.html#4.12">4.12,
Scripting</a>. Browsers supporting a scripting language for which a language
binding is specified shall adhere to that language binding.</p>

<p>Sometime before a script receives the first event it shall be initialized
(any language-dependent or user-defined <code>initialize()</code> is performed).
The script is able to receive and process events that are sent to it. Each
event that can be received shall be declared in the Script node using the
same syntax as is used in a prototype definition:</p>

<pre>
    eventIn <i>type name</i></pre>

<p>The <i>type</i> can be any of the standard VRML fields (as defined in
<a HREF="fieldsRef.html">5, Field and event reference</a>). <i>Name</i>
shall be an identifier that is unique for this Script node.</p>

<p>The Script node is able to generate events in response to the incoming
events. Each event that may be generated shall be declared in the Script
node using the following syntax:</p>

<pre>
    eventOut <i>type name</i></pre>

<p>With the exception of the <i>url </i>field<i>,</i> exposedFields are
not allowed in Script nodes.</p>

<p>If the Script node's <i>mustEvaluate</i> field is FALSE, the browser
may delay sending input events to the script until its outputs are needed
by the browser. If the <i>mustEvaluate</i> field is TRUE, the browser shall
send input events to the script as soon as possible, regardless of whether
the outputs are needed. The <i>mustEvaluate</i> field shall be set to TRUE
only if the Script node has effects that are not known to the browser (such
as sending information across the network). Otherwise, poor performance
may result.</p>

<p>Once the script has access to a VRML node (via an SFNode or MFNode value
either in one of the Script node's fields or passed in as an eventIn), the
script is able to read the contents of that node's exposed fields. If the
Script node's <i>directOutput</i> field is TRUE, the script may also send
events directly to any node to which it has access, and may dynamically
establish or break routes. If <i>directOutput</i> is FALSE (the default),
the script may only affect the rest of the world via events sent through
its eventOuts. The results are undefined if <i>directOutput</i> is FALSE
and the script sends events directly to a node to which it has access.</p>

<p>A script is able to communicate directly with the VRML browser to get
information such as the current time and the current world URL. This is
strictly defined by the API for the specific scripting language being used.</p>

<p>The location of the Script node in the scene graph has no affect on its
operation. For example, if a parent of a Script node is a Switch node with
<i>whichChoice</i> set to &quot;-1&quot; (i.e.,&nbsp;ignore its children),
the Script node continues to operate as specified (i.e.,&nbsp;it receives
and sends events).</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Shape"></a>6.41 Shape</h2>

<p><b>Shape { </b></p>

<pre>
  exposedField SFNode <b>appearance NULL</b>
  exposedField SFNode <b>geometry   NULL</b>
<b>}</b></pre>

<p>The Shape node has two fields, <i>appearance</i> and <i>geometry,</i>
which are used to create rendered objects in the world. The <i>appearance</i>
field contains an <a HREF="nodesref.html#Appearance">Appearance</a> node that specifies
the visual attributes (e.g.,&nbsp;material and texture) to be applied to
the geometry. The <i>geometry</i> field contains a geometry node. The specified
geometry node is rendered with the specified appearance nodes applied. See
<a HREF="concepts.html#4.6.3">4.6.3, Shapes and geometry</a>, and <a HREF="nodesref.html#Appearance">6.3,&nbsp;Appearance</a>, for more information.</p>

<p><a HREF="concepts.html#4.14">4.14, Lighting model</a>, contains details
of the VRML lighting model and the interaction between Appearance nodes
and geometry nodes.</p>

<p>If the <i>geometry</i> field is NULL, the object is not drawn.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Sound"></a>6.42 Sound</h2>

<pre>
<b>Sound { </b>
  exposedField SFVec3f  <b>direction     0 0 1   </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat <b> intensity     1       </b># [0,1]
  exposedField SFVec3f  <b>location      0 0 0   </b># (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat  <b>maxBack       10      </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat  <b>maxFront      10      </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat  <b>minBack       1       </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat  <b>minFront      1       </b># [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat <b> priority      0       </b># [0,1]
  exposedField SFNode   <b>source        NULL</b>
  field        SFBool   <b>spatialize    TRUE</b>
<b>}</b></pre>

<p>The Sound node specifies the spatial presentation of a sound in a VRML
scene. The sound is located at a point in the local coordinate system and
emits sound in an elliptical pattern (defined by two ellipsoids). The ellipsoids
are oriented in a direction specified by the <i>direction</i> field. The
shape of the ellipsoids may be modified to provide more or less directional
focus from the location of the sound.</p>

<p>The <i>source</i> field specifies the sound source for the Sound node.
If the <i>source</i> field is not specified, the Sound node will not emit
audio. The <i>source</i> field shall specify either an AudioClip node or
a MovieTexture node. If a MovieTexture node is specified as the sound source,
the MovieTexture shall refer to a movie format that supports sound (e.g.,&nbsp;MPEG1-Systems,
see <a HREF="references.html#[MPEG]">2.[MPEG]</a>).</p>

<p>The <i>intensity </i>field adjusts the loudness (decibels) of the sound
emitted by the Sound node (note:&nbsp;this is different from the traditional
definition of intensity with respect to sound; see <a HREF="bibliography.html#[SNDA]">E.[SNDA]</a>).
The <i>intensity</i> field has a value that ranges from 0.0 to 1.0 and specifies
a factor which shall be used to scale the normalized sample data of the
sound source during playback. A Sound node with an intensity of 1.0 shall
emit audio at its maximum loudness (before attenuation), and a Sound node
with an intensity of 0.0 shall emit no audio. Between these values, the
loudness should increase linearly from a -20 dB change approaching an <i>intensity</i>
of 0.0 to a 0 dB change at an <i>intensity</i> of 1.0.</p>

<p>The <i>priority</i> field provides a hint for the browser to choose which
sounds to play when there are more active Sound nodes than can be played
at once due to either limited system resources or system load. <a HREF="conformance.html#7.3.4">7.3.4, Sound priority, attenuation, and spatialization</a>,
describes a recommended algorithm for determining which sounds to play under
such circumstances. The <i>priority</i> field ranges from 0.0 to 1.0, with
1.0 being the highest priority and 0.0 the lowest priority.</p>

<p>The <i>location</i> field determines the location of the sound emitter
in the local coordinate system. A Sound node's output is audible only if
it is part of the traversed scene. Sound nodes that are descended from LOD,
Switch, or any grouping or prototype node that disables traversal (i.e.,<i>&nbsp;</i>drawing)
of its children are not audible unless they are traversed. If a Sound node
is disabled by a Switch or LOD node, and later it becomes part of the traversal
again, the sound shall resume where it would have been had it been playing
continuously.</p>

<p>The Sound node has an inner ellipsoid that defines a volume of space
in which the maximum level of the sound is audible. Within this ellipsoid,
the normalized sample data is scaled by the <i>intensity</i> field and there
is no attenuation. The inner ellipsoid is defined by extending the <i>direction</i>
vector through the <i>location</i>. The <i>minBack</i> and <i>minFront</i>
fields specify distances behind and in front of the <i>location</i> along
the <i>direction</i> vector respectively. The inner ellipsoid has one of
its foci at <i>location</i> (the second focus is implicit) and intersects
the <i>direction</i> vector at <i>minBack</i> and <i>minFront</i>.</p>

<p>The Sound node has an outer ellipsoid that defines a volume of space
that bounds the audibility of the sound. No sound can be heard outside of
this outer ellipsoid. The outer ellipsoid is defined by extending the <i>direction</i>
vector through the <i>location</i>. The <i>maxBack</i> and <i>maxFront </i>fields
specify distances behind and in front of the <i>location</i> along the <i>direction</i>
vector respectively. The outer ellipsoid has one of its foci at <i>location</i>
(the second focus is implicit) and intersects the <i>direction</i> vector
at <i>maxBack</i> and <i>maxFront</i>.</p>

<p>The <i>minFront</i>, <i>maxFront</i>, <i>minBack</i>, and <i>maxBack</i>
fields are defined in local coordinates, and shall be greater than or equal
to zero. The <i>minBack</i> field shall be less than or equal to&nbsp;<i>maxBack</i>,
and <i>minFront</i> shall be less than or equal to&nbsp;<i>maxFront.</i>
The ellipsoid parameters are specified in the local coordinate system but
the ellipsoids' geometry is affected by ancestors' transformations.</p>

<p>Between the two ellipsoids, there shall be a linear attenuation ramp
in loudness, from 0 dB at the minimum ellipsoid to -20 dB at the maximum
ellipsoid:</p>

<pre>
    attenuation = -20 × (d' / d&quot;)</pre>

<p>where d' is the distance along the location-to-viewer vector, measured
from the transformed minimum ellipsoid boundary to the viewer, and d&quot;
is the distance along the location-to-viewer vector from the transformed
minimum ellipsoid boundary to the transformed maximum ellipsoid boundary
(see <a HREF="nodesref.html#Figure6.14">Figure 6.14</a>).</p>

<p><center><a NAME="Figure6.14"></a><img SRC="../Images/Sound.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/Sound.gif" WIDTH="408" HEIGHT="289" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Sound Node Geometry"></center></p>

<p><center><b>Figure 6.14 -- Sound node geometry</b></center></p>

<p>The <i>spatialize</i> field specifies if the sound is perceived as being
directionally located relative to the viewer. If the <i>spatialize </i>field
is TRUE and the viewer is located between the transformed inner and outer
ellipsoids, the viewer's direction and the relative location of the Sound
node should be taken into account during playback. Details outlining the
minimum required spatialization functionality can be found in <a HREF="conformance.html#7.3.4">7.3.4,
Sound priority, attenuation, and spatialization</a>. If the <i>spatialize</i>
field is FALSE, then directional effects are ignored, but the ellipsoid
dimensions and<i> intensity</i> will still affect the loudness of the sound.
If the sound source is multi-channel (e.g.,&nbsp;stereo), then the source
should retain its channel separation during playback.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Sphere"></a>6.43 Sphere</h2>

<pre>
<b>Sphere { </b>
  field SFFloat <b>radius  1 </b>   # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The Sphere node specifies a sphere centred at (0, 0, 0) in the local
coordinate system. The <i>radius</i> field specifies the radius of the sphere
and shall be greater than zero. <a HREF="nodesref.html#Figure6.15">Figure 6.15</a> depicts
the fields of the Sphere node.</p>

<p><center><a NAME="Figure6.15"></a><img SRC="../Images/sphere.gif" WIDTH="342" HEIGHT="334" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/sphere.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="Sphere node"></center></p>

<h4><center>Figure 6.15 -- Sphere node</center></h4>

<p>When a texture is applied to a sphere, the texture covers the entire
surface, wrapping counterclockwise from the back of the sphere (i.e., longitudinal
arc intersecting the -Z-axis) when viewed from the top of the sphere. The
texture has a seam at the back where the X=0 plane intersects the sphere
and Z values are negative. <a HREF="nodesref.html#TextureTransform">TextureTransform</a>
affects the texture coordinates of the Sphere.</p>

<p>The Sphere node's geometry requires outside faces only. When viewed from
the inside the results are undefined.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="SphereSensor"></a>6.44 SphereSensor</h2>

<pre>
<b>SphereSensor { </b>
  exposedField SFBool     <b>autoOffset</b>        <b>TRUE</b>
  exposedField SFBool     <b>enabled           TRUE</b>
  exposedField SFRotation <b>offset</b>            <b>0 1 0 0  </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFBool     isActive
  eventOut     SFRotation rotation_changed
  eventOut     SFVec3f    trackPoint_changed
<b>}</b></pre>

<p>The SphereSensor node maps pointing device motion into spherical rotation
about the origin of the local coordinate system. The SphereSensor node uses
the descendent geometry of its parent node to determine whether it is liable
to generate events.</p>

<p>The <i>enabled</i> exposed field enables and disables the SphereSensor
node. If <i>enabled</i> is TRUE, the sensor reacts appropriately to user
events. If <i>enabled</i> is FALSE, the sensor does not track user input
or send events. If <i>enabled</i> receives a FALSE event and <i>isActive</i>
is TRUE, the sensor becomes disabled and deactivated, and outputs an <i>isActive</i>
FALSE event. If <i>enabled</i> receives a TRUE event the sensor is enabled
and ready for user activation.</p>

<p>The SphereSensor node generates events when the pointing device is activated
while the pointer is indicating any descendent geometry nodes of the sensor's
parent group. See <a HREF="concepts.html#4.6.7.5">4.6.7.5,&nbsp;Activating&nbsp;and&nbsp;manipulating&nbsp;sensors</a>,
for details on using the pointing device to activate the SphereSensor.</p>

<p>Upon activation of the pointing device (e.g.,&nbsp;mouse button down)
over the sensor's geometry, an <i>isActive</i> TRUE event is sent. The vector
defined by the initial point of intersection on the SphereSensor's geometry
and the local origin determines the radius of the sphere that is used to
map subsequent pointing device motion while dragging. The virtual sphere
defined by this radius and the local origin at the time of activation is
used to interpret subsequent pointing device motion and is not affected
by any changes to the sensor's coordinate system while the sensor is active.
For each position of the bearing, a <i>rotation_changed</i> event is sent
which corresponds to the sum of the relative rotation from the original
intersection point plus the <i>offset</i> value. <i>trackPoint_changed</i>
events reflect the unclamped drag position on the surface of this sphere.
When the pointing device is deactivated and <i>autoOffset</i> is TRUE, <i>offset</i>
is set to the last <i>rotation_changed</i> value and an <i>offset_changed</i>
event is generated. See <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag sensors</a>,
for more details.</p>

<p>When the sensor generates an <i>isActive</i> TRUE event, it grabs all
further motion events from the pointing device until it is released and
generates an <i>isActive</i> FALSE event (other pointing-device sensors
shall not generate events during this time). Motion of the pointing device
while <i>isActive</i> is TRUE is termed a &quot;drag&quot;. If a 2D pointing
device is in use, <i>isActive</i> events will typically reflect the state
of the primary button associated with the device (i.e.,&nbsp;<i>isActive</i>
is TRUE when the primary button is pressed and FALSE when it is released).
If a 3D pointing device (e.g.,&nbsp;wand) is in use, <i>isActive</i> events
will typically reflect whether the pointer is within (or in contact with)
the sensor's geometry.</p>

<p>While the pointing device is activated,<i> trackPoint_changed</i> and
<i>rotation_changed</i> events are output. <i>trackPoint_changed</i> events
represent the unclamped intersection points on the surface of the invisible
sphere. If the pointing device is dragged off the sphere while activated,
browsers may interpret this in a variety of ways (e.g., clamp all values
to the sphere or continue to rotate as the point is dragged away from the
sphere). Each movement of the pointing device while <i>isActive</i> is TRUE
generates <i>trackPoint_changed</i> and <i>rotation_changed</i> events.</p>

<p>Further information about this behaviour can be found in <a HREF="concepts.html#4.6.7.3">4.6.7.3,
Pointing-device sensors</a>, <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>, and <a HREF="concepts.html#4.6.7.5">4.6.7.5, Activating and
manipulating sensors</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="SpotLight"></a>6.45 SpotLight</h2>

<pre>
<b>SpotLight { </b>
  exposedField SFFloat <b>ambientIntensity  0</b>         # [0,1]
  exposedField SFVec3f <b>attenuation       1 0 0</b>     # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat <b>beamWidth         1.570796</b>  # (0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2]
  exposedField SFColor <b>color             1 1 1</b>     # [0,1]
  exposedField SFFloat <b>cutOffAngle       0.785398</b>  # (0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2]
  exposedField SFVec3f <b>direction         0 0 -1</b>    # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat <b>intensity         1</b>         # [0,1]
  exposedField SFVec3f <b>location          0 0 0</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool  <b>on                TRUE</b>
  exposedField SFFloat <b>radius            100</b>       # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The SpotLight node defines a light source that emits light from a specific
point along a specific direction vector and constrained within a solid angle.
Spotlights may illuminate geometry nodes that respond to light sources and
intersect the solid angle defined by the SpotLight. Spotlight nodes are
specified in the local coordinate system and are affected by ancestors'
transformations.</p>

<p>A detailed description of <i>ambientIntensity,</i> <i>color</i>, <i>intensity</i>,
and VRML's lighting equations is provided in <a HREF="concepts.html#4.6.6">4.6.6,
Light sources</a>. More information on lighting concepts can be found in
<a HREF="concepts.html#4.14">4.14,&nbsp;Lighting model</a>, including a
detailed description of the VRML lighting equations.</p>

<p>The <i>location</i> field specifies a translation offset of the centre
point of the light source from the light's local coordinate system origin.
This point is the apex of the solid angle which bounds light emission from
the given light source. The <i>direction</i> field specifies the direction
vector of the light's central axis defined in the local coordinate system.</p>

<p>The <i>on</i> field specifies whether the light source emits light. If
<i>on</i> is TRUE, the light source is emitting light and may illuminate
geometry in the scene. If <i>on</i> is FALSE, the light source does not
emit light and does not illuminate any geometry.</p>

<p>The <i>radius</i> field specifies the radial extent of the solid angle
and the maximum distance from <i>location</i> that may be illuminated by
the light source. The light source does not emit light outside this radius.
The <i>radius</i> shall be greater than or equal to zero.</p>

<p>Both radius and location are affected by ancestors' transformations (scales
affect <i>radius</i> and transformations affect <i>location</i>).</p>

<p>The <i>cutOffAngle</i> field specifies the outer bound of the solid angle.
The light source does not emit light outside of this solid angle. The <i>beamWidth</i>
field specifies an inner solid angle in which the light source emits light
at uniform full intensity. The light source's emission intensity drops off
from the inner solid angle (<i>beamWidth</i>) to the outer solid angle (<i>cutOffAngle</i>)
as described in the following equations:</p>

<pre>
    angle = the angle between the Spotlight's direction vector
            and the vector from the Spotlight location to the point
            to be illuminated

    if (angle &gt;= cutOffAngle):
        multiplier = 0
    else if (angle &lt;= beamWidth):
        multiplier = 1
    else:
        multiplier = (angle - cutOffAngle) / (beamWidth - cutOffAngle)

    intensity(angle) = SpotLight.intensity × multiplier</pre>

<p>If the <i>beamWidth</i> is greater than the <i>cutOffAngle</i>, <i>beamWidth</i>
is defined to be equal to the <i>cutOffAngle</i> and the light source emits
full intensity within the entire solid angle defined by <i>cutOffAngle</i>.
Both <i>beamWidth</i> and <i>cutOffAngle</i> shall be greater than 0.0 and
less than or equal to <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2. <a HREF="nodesref.html#Figure6.16">Figure
6.16</a> depicts the <i>beamWidth</i>, <i>cutOffAngle</i>, <i>direction</i>,
<i>location</i>, and <i>radius</i> fields of the SpotLight node.</p>

<h4><center><a NAME="Figure6.16"></a><img SRC="../Images/spotlight.gif" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/spotlight.gif" SGI_WIDTH_UNFIXED SGI_HEIGHT_UNFIXED WIDTH="396" HEIGHT="297" NATURALSIZEFLAG="0" ALIGN="BOTTOM" ALT="SpotLight node"></center></h4>

<h4><center>Figure 6.16 -- SpotLight node</center></h4>

<p>SpotLight illumination falls off with distance as specified by three
<i>attenuation</i> coefficients. The attenuation factor is 1<i>/max(attenuation[0]&nbsp;+&nbsp;attenuation[1]</i>×<i>r&nbsp;+&nbsp;attenuation[2]</i>×<i>r</i><sup>2</sup>&nbsp;,&nbsp;1<i>)</i>,
where <i>r</i> is the distance from the light to the surface being illuminated.
The default is no attenuation. An <i>attenuation</i> value of (0, 0, 0)
is identical to (1, 0, 0). Attenuation values shall be greater than or equal
to zero. A detailed description of VRML's lighting equations is contained
in <a HREF="concepts.html#4.14">4.14, Lighting model</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Switch"></a>6.46 Switch</h2>

<pre>
<b>Switch { </b>
  exposedField    MFNode  <b>choice      []</b>
  exposedField    SFInt32 <b>whichChoice -1</b>    # [-1,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The Switch grouping node traverses zero or one of the nodes specified
in the <i>choice</i> field.</p>

<p><a HREF="concepts.html#4.6.5">4.6.5, Grouping and children nodes</a>,
describes details on the types of nodes that are legal values for <i>choice</i>.</p>

<p>The <i>whichChoice </i>field specifies the index of the child to traverse,
with the first child having index 0. If <i>whichChoice </i>is less than
zero or greater than the number of nodes in the <i>choice</i> field, nothing
is chosen.</p>

<p>All nodes under a Switch continue to receive and send events regardless
of the value of <i>whichChoice</i>. For example, if an active TimeSensor
is contained within an inactive choice of an Switch, the TimeSensor sends
events regardless of the Switch's state.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Text"></a>6.47 Text</h2>

<pre>
<b>Text { </b>
  exposedField  MFString <b>string    []</b>
  exposedField  SFNode <b>  fontStyle NULL</b>
  exposedField  MFFloat  <b>length    []</b>      # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField  SFFloat  <b>maxExtent 0.0    </b> # [0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<h3>6.47.1 Introduction</h3>

<p>The Text node specifies a two-sided, flat text string object positioned
in the Z=0 plane of the local coordinate system based on values defined
in the fontStyle field (see <a HREF="nodesref.html#FontStyle">6.20,&nbsp;FontStyle</a>).
Text nodes may contain multiple text strings specified using the UTF-8 encoding
as specified by ISO&nbsp;10646-1:1993 (see <a HREF="references.html#[UTF8]">2.[UTF8]</a>).
The text strings are stored in the order in which the text mode characters
are to be produced as defined by the parameters in the FontStyle node.</p>

<p>The text strings are contained in the <i>string</i> field. The <i>fontStyle</i>
field contains one <a HREF="nodesref.html#FontStyle">FontStyle</a> node that specifies
the font size, font family and style, direction of the text strings, and
any specific language rendering techniques used for the text.</p>

<p>The <i>maxExtent</i> field limits and compresses all of the text strings
if the length of the maximum string is longer than the maximum extent, as
measured in the local coordinate system. If the text string with the maximum
length is shorter than the <i>maxExtent</i>, then there is no compressing.
The maximum extent is measured horizontally for horizontal text (<a HREF="nodesref.html#FontStyle">FontStyle</a> node: <i>horizontal</i>=TRUE) and vertically
for vertical text (<a HREF="nodesref.html#FontStyle">FontStyle</a> node: <i>horizontal</i>=FALSE).
The <i>maxExtent</i> field shall be greater than or equal to zero.</p>

<p>The <i>length</i> field contains an MFFloat value that specifies the
length of each text string in the local coordinate system. If the string
is too short, it is stretched (either by scaling the text or by adding space
between the characters). If the string is too long, it is compressed (either
by scaling the text or by subtracting space between the characters). If
a length value is missing (for example, if there are four strings but only
three length values), the missing values are considered to be 0. The <i>length</i>
field shall be greater than or equal to zero.</p>

<p>Specifying a value of 0 for both the <i>maxExtent</i> and <i>length</i>
fields indicates that the string may be any length.</p>

<h3>6.47.2 ISO 10646-1:1993 Character Encodings</h3>

<p>Characters in ISO 10646 (see <a HREF="references.html#[UTF8]">2.[UTF8]</a>)
are encoded in multiple octets. Code space is divided into four units, as
follows:</p>

<pre>
+-------------+-------------+-----------+------------+
| Group-octet | Plane-octet | Row-octet | Cell-octet |
+-------------+-------------+-----------+------------+</pre>

<p>ISO 10646-1:1993 allows two basic forms for characters:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>UCS-2 (Universal Coded Character Set-2). This form is also known as
  the Basic Multilingual Plane (BMP). Characters are encoded in the lower
  two octets (row and cell).
  <li>UCS-4 (Universal Coded Character Set-4). Characters are encoded in
  the full four octets.
</ol><!--/NOEDIT--></p>

<p>In addition, three transformation formats (UCS Transformation Format
or UTF) are accepted: UTF-7, UTF-8, and UTF-16. Each represents the nature
of the transformation: 7-bit, 8-bit, or 16-bit. UTF-7 and UTF-16 are referenced
in <a HREF="references.html#[UTF8]">2.[UTF8]</a>.</p>

<p>UTF-8 maintains transparency for all ASCII code values (0...127). It
allows ASCII text (0x0..0x7F) to appear without any changes and encodes
all characters from 0x80.. 0x7FFFFFFF into a series of six or fewer bytes.</p>

<p>If the most significant bit of the first character is 0, the remaining
seven bits are interpreted as an ASCII character. Otherwise, the number
of leading 1 bits indicates the number of bytes following. There is always
a zero bit between the count bits and any data.</p>

<p>The first byte is one of the following. The X indicates bits available
to encode the character:</p>

<pre>
 0XXXXXXX only one byte   0..0x7F (ASCII)
 110XXXXX two bytes       Maximum character value is 0x7FF
 1110XXXX three bytes     Maximum character value is 0xFFFF
 11110XXX four bytes      Maximum character value is 0x1FFFFF
 111110XX five bytes      Maximum character value is 0x3FFFFFF
 1111110X six bytes       Maximum character value is 0x7FFFFFFF</pre>

<p>All following bytes have the format 10XXXXXX.</p>

<p>As a two byte example, the symbol for a register trade mark is &amp;REG;
or 174 in ISO Latin-1 (see&nbsp;<a HREF="references.html#[I8859]">2.[I8859]</a>).
It is encoded as 0x00AE in UCS-2 of ISO 10646. In UTF-8, it has the following
two byte encoding: 0xC2, 0xAE.</p>

<h3>6.47.3 Appearance</h3>

<p>Textures are applied to text as follows. The texture origin is at the
origin of the first string, as determined by the justification. The texture
is scaled equally in both S and T dimensions, with the font height representing
1 unit. S increases to the right, and T increases up.</p>

<p><a HREF="concepts.html#4.14">4.14, Lighting model</a>, has details on
VRML lighting equations and how Appearance, Material and textures interact
with lighting.</p>

<p>The Text node does not participate in collision detection.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="TextureCoordinate"></a>6.48 TextureCoordinate</h2>

<pre>
<b>TextureCoordinate { </b>
  exposedField MFVec2f <b>point  []</b>      # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The TextureCoordinate node specifies a set of 2D texture coordinates
used by vertex-based geometry nodes (e.g.,&nbsp;<a HREF="nodesref.html#IndexedFaceSet">IndexedFaceSet</a>
and <a HREF="nodesref.html#ElevationGrid">ElevationGrid</a>) to map textures to vertices.
Textures are two dimensional colour functions that, given an <i>(s,&nbsp;t)</i>
coordinate, return a colour value <i>colour(s,&nbsp;t)</i>. Texture map
values (<a HREF="nodesref.html#ImageTexture">ImageTexture</a>, <a HREF="nodesref.html#MovieTexture">MovieTexture</a>,
and <a HREF="nodesref.html#PixelTexture">PixelTexture</a>) range from [0.0, 1.0] along
the S-axis and T-axis. However, TextureCoordinate values, specified by the
<i>point</i> field, may be in the range (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3"><i>,</i><img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">). Texture coordinates identify
a location (and thus a colour value) in the texture map. The horizontal
coordinate <i>s</i> is specified first, followed by the vertical coordinate
<i>t</i>.</p>

<p>If the texture map is repeated in a given direction (S-axis or T-axis),
a texture coordinate C (s or t) is mapped into a texture map that has N
pixels in the given direction as follows:</p>

<pre>
    Texture map location = (C - floor(C)) × N</pre>

<p>If the texture map is not repeated, the texture coordinates are clamped
to the 0.0 to 1.0 range as follows:</p>

<pre>
    Texture map location = N,     if C &gt; 1.0,
                         = 0.0,   if C &lt; 0.0,
                         = C × N, if 0.0 &lt;= C &lt;= 1.0.</pre>

<p>Details on repeating textures are specific to texture map node types
described in <a HREF="nodesref.html#ImageTexture">6.22,&nbsp;ImageTexture</a>, <a HREF="nodesref.html#MovieTexture">6.28,&nbsp;MovieTexture</a>, and <a HREF="nodesref.html#PixelTexture">6.33,&nbsp;PixelTexture</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="TextureTransform"></a>6.49 TextureTransform</h2>

<pre>
<b>TextureTransform { </b>
  exposedField SFVec2f <b>center      0 0</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFFloat<b> rotation    0  </b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec2f <b>scale       1 1</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec2f <b>translation 0 0</b>     # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
<b>}</b></pre>

<p>The TextureTransform node defines a 2D transformation that is applied
to texture coordinates (see <a HREF="nodesref.html#TextureCoordinate">6.48,&nbsp;TextureCoordinate</a>).
This node affects the way textures coordinates are applied to the geometric
surface. The transformation consists of (in order):</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>a translation;
  <li>a rotation about the centre point;
  <li>a non-uniform scale about the centre point.
</ol><!--/NOEDIT--></p>

<p>These parameters support changes to the size, orientation, and position
of textures on shapes. Note that these operations appear reversed when viewed
on the surface of geometry. For example, a <i>scale</i> value of (2 2) will
scale the texture coordinates and have the net effect of shrinking the texture
size by a factor of 2 (texture coordinates are twice as large and thus cause
the texture to repeat). A translation of (0.5 0.0)<b> </b>translates the
texture coordinates +.5 units along the S-axis and has the net effect of
translating the texture -0.5 along the S-axis on the geometry's surface.
A rotation of <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2 of the texture coordinates
results in a -<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">/2 rotation of the texture on
the geometry.</p>

<p>The <i>center</i> field specifies a translation offset in texture coordinate
space about which the <i>rotation</i> and <i>scale</i> fields are applied.
The <i>scale</i> field specifies a scaling factor in S and T of the texture
coordinates about the <i>center</i> point. <i>scale</i> values shall be
in the range (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">, <img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3"><i>)</i>. The <i>rotation</i>
field specifies a rotation in radians of the texture coordinates about the
<i>center</i> point after the scale has been applied. A positive rotation
value makes the texture coordinates rotate counterclockwise about the centre,
thereby rotating the appearance of the texture itself clockwise. The <i>translation</i>
field specifies a translation of the texture coordinates.</p>

<p>In matrix transformation notation, where<i> Tc</i> is the untransformed
texture coordinate, <i>Tc'</i> is the transformed texture coordinate, <i>C</i>
(<i>center</i>), <i>T</i> (<i>translation</i>), <i>R</i> (<i>rotation</i>),
and <i>S</i> (<i>scale</i>) are the intermediate transformation matrices,</p>

<pre>
    Tc' = -C × S × R × C × T × Tc</pre>

<p>Note that this transformation order is the reverse of the Transform node
transformation order since the texture coordinates, not the texture, are
being transformed (i.e.,&nbsp;the texture coordinate system).</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="TimeSensor"></a>6.50 TimeSensor</h2>

<pre>
<b>TimeSensor { </b>
  exposedField SFTime   <b>cycleInterval 1</b>       # (0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool   <b>enabled       TRUE</b>
  exposedField SFBool   <b>loop          FALSE</b>
  exposedField SFTime   <b>startTime     0</b>       # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFTime   <b>stopTime      0</b>       # (-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFTime   cycleTime
  eventOut     SFFloat  fraction_changed      # [0,&nbsp;1]
  eventOut     SFBool   isActive
  eventOut     SFTime   time
<b>}</b></pre>

<p>TimeSensor nodes generate events as time passes. TimeSensor nodes can
be used for many purposes including:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>driving continuous simulations and animations;
  <li>controlling periodic activities (<i>e.g.</i>, one per minute);
  <li>initiating single occurrence events such as an alarm clock.
</ol><!--/NOEDIT--></p>

<p>The TimeSensor node contains two discrete eventOuts: <i>isActive</i>
and <i>cycleTime</i>. The <i>isActive</i> eventOut sends TRUE when the TimeSensor
node begins running, and FALSE when it stops running. The <i>cycleTime</i>
eventOut sends a time event at <i>startTime</i> and at the beginning of
each new cycle (useful for synchronization with other time-based objects).
The remaining eventOuts generate continuous events. The <i>fraction_changed</i>
eventOut, an SFFloat in the closed interval [0,1], sends the completed fraction
of the current cycle. The <i>time</i> eventOut sends the absolute time for
a given <i>simulation tick</i>.</p>

<p>If the <i>enabled</i> exposedField is TRUE, the TimeSensor node is enabled
and may be running. If a <i>set_enabled </i>FALSE event is received while
the TimeSensor node is running, the sensor performs the following actions:</p>

<p><!--NOEDIT--><ol START="4" TYPE="a">
  <li>evaluates and sends all relevant outputs;
  <li>sends a FALSE value for <i>isActive</i>;
  <li>disables itself.
</ol><!--/NOEDIT--></p>

<p>Events on the exposedFields of the TimeSensor node (e.g.,<i>&nbsp;set_startTime)
</i>are processed and their corresponding eventOuts (e.g.,<i>&nbsp;startTime_changed)</i>
are sent regardless of the state of the <i>enabled </i>field. The remaining
discussion assumes <i>enabled</i> is TRUE.</p>

<p>The <i>loop, startTime,</i> and <i>stopTime</i> exposedFields and the
<i>isActive</i> eventOut and their effects on the TimeSensor node are discussed
in detail in <a HREF="concepts.html#4.6.9">4.6.9,&nbsp;Time-dependent nodes</a>.
The &quot;cycle<i>&quot;</i> of a TimeSensor node lasts for <i>cycleInterval</i>
seconds. The value of <i>cycleInterval</i> shall be greater than&nbsp;zero.</p>

<p>A <i>cycleTime</i> eventOut can be used for synchronization purposes
such as sound with animation. The value of a <i>cycleTime</i> eventOut will
be equal to the time at the beginning of the current cycle. A <i>cycleTime
</i>eventOut is generated at the beginning of every cycle, including the
cycle starting at <i>startTime</i>. The first <i>cycleTime</i> eventOut
for a TimeSensor node can be used as an alarm (single pulse at a specified
time).</p>

<p>When a TimeSensor node becomes active, it generates an <i>isActive =
</i>TRUE event and<i> </i>begins generating <i>time,</i> <i>fraction_changed,</i>
and <i>cycleTime </i>events which may be routed to other nodes to drive
animation or simulated behaviours. The behaviour at read time is described
below. The<i> time</i> event sends the absolute time for a given tick of
the TimeSensor node (<a HREF="fieldsRef.html#SFTime">time</a> fields and
events represent the number of seconds since midnight GMT January&nbsp;1,
1970).</p>

<p><i>fraction_changed</i> events output a floating point value in the closed
interval [0,&nbsp;1]. At <i>startTime</i> the value of <i>fraction_changed</i>
is 0. After <i>startTime,</i> the value of <i>fraction_changed</i> in any
cycle will progress through the range (0.0, 1.0]. At <i>startTime&nbsp;+&nbsp;</i>N&nbsp;×&nbsp;<i>cycleInterval,
</i>for N = 1, 2, ..., that is, at the end of every cycle, the value of
<i>fraction_changed</i> is 1.</p>

<p>Let <i>now</i> represent the time at the current simulation tick. Then
the <i>time</i> and <i>fraction_changed </i>eventOuts<i> </i>can then be
computed as:</p>

<pre>
<i>   </i> <i>time </i>= <i>now</i>
    temp = (<i>now</i> - startTime) / cycleInterval
    f    = fractionalPart(temp)
    if (f == 0.0 &amp;&amp; <i>now</i> &gt; startTime) <i>fraction_changed</i> = 1.0
    else <i>fraction_changed</i> = f</pre>

<p>where<tt> fractionalPart(x) </tt>is a function that returns the fractional
part, (that is, the digits to the right of the decimal point), of a nonnegative
floating point number.</p>

<p>A TimeSensor node can be set up to be active at read time by specifying
<i>loop</i> TRUE (not the default) and <i>stopTime&nbsp;</i>less than or
equal to<i>&nbsp;startTime</i> (satisfied by the default values). The <i>time</i>
events output absolute times for each tick of the TimeSensor node simulation.
The <i>time</i> events shall start at the first simulation tick greater
than or equal to <i>startTime.</i> <i>time</i> events end at <i>stopTime</i>,
or at <i>startTime&nbsp;</i>+&nbsp;<i>N&nbsp;</i>×&nbsp;<i>cycleInterval</i>
for some positive integer value of <i>N</i>, or loop forever depending on
the values of the other fields. An active TimeSensor node shall stop at
the first simulation tick when <i>now&nbsp;</i>&gt;=&nbsp;<i>stopTime&nbsp;&gt;&nbsp;startTime</i>.</p>

<p>No guarantees are made with respect to how often a TimeSensor node generates
time events, but a TimeSensor node shall generate events at least at every
simulation tick. TimeSensor nodes are guaranteed to generate final <i>time</i>
and <i>fraction_changed</i> events. If loop is FALSE at the end of the <i>N</i>th
cycleInterval and was TRUE at <i>startTime&nbsp;+&nbsp;M&nbsp;</i>×&nbsp;<i>cycleInterval</i>
for all <i>0&nbsp;&lt;&nbsp;M&nbsp;&lt;&nbsp;N</i>, the final <i>time</i>
event will be generated with a value of (<i>startTime&nbsp;+&nbsp;N&nbsp;</i>×&nbsp;<i>cycleInterval</i>)
or <i>stopTime (</i>if <i>stopTime&nbsp;</i>&gt;&nbsp;<i>startTime), </i>whichever
value is less. If <i>loop</i> is TRUE at the completion of every cycle,
the final event is generated as evaluated at <i>stopTime</i> (if <i>stopTime&nbsp;</i>&gt;&nbsp;<i>startTime)</i>
or never<i>.</i></p>

<p>An active TimeSensor node ignores <i>set_cycleInterval</i> and <i>set_startTime</i>
events. An active TimeSensor node also ignores <i>set_stopTime</i> events
for <i>set_stopTime&nbsp;</i>less than or equal to<i>&nbsp;startTime</i>.
For example, if a <i>set_startTime</i> event is received while a TimeSensor
node is active, that <i>set_startTime</i> event is ignored (the <i>startTime</i>
field is not changed, and a <i>startTime_changed</i> eventOut is not generated).
If an active TimeSensor node receives a<i> set_stopTime</i> event that is
less than the current time, and greater than <i>startTime</i>, it behaves
as if the <i>stopTime</i> requested is the current time and sends the final
events based on the current time (note that <i>stopTime </i>is set as specified
in the eventIn).</p>

<p>A TimeSensor read from a VRML file shall generate <i>isActive </i>TRUE,
<i>time</i> and <i>fraction_changed</i> events if the sensor is enabled
and all conditions for a TimeSensor to be active are met.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="TouchSensor"></a>6.51 TouchSensor</h2>

<pre>
<b>TouchSensor { </b>
  exposedField SFBool <b> enabled TRUE</b>
  eventOut     SFVec3f hitNormal_changed
  eventOut     SFVec3f hitPoint_changed
  eventOut     SFVec2f hitTexCoord_changed
  eventOut     SFBool  isActive
  eventOut     SFBool  isOver
  eventOut     SFTime  touchTime
<b>}</b></pre>

<p>A TouchSensor node tracks the location and state of the pointing device
and detects when the user points at geometry contained by the TouchSensor
node's parent group. A TouchSensor node can be enabled or disabled by sending
it an <i>enabled</i> event with a value of TRUE or FALSE. If the TouchSensor
node is disabled, it does not track user input or send events.</p>

<p>The TouchSensor generates events when the pointing device points toward
any geometry nodes that are descendants of the TouchSensor's parent group.
See&nbsp;<a HREF="concepts.html#4.6.7.5">4.6.7.5,&nbsp;Activating&nbsp;and&nbsp;manipulating&nbsp;sensors</a>,
for more details on using the pointing device to activate the TouchSensor.</p>

<p>The <i>isOver</i> eventOut reflects the state of the pointing device
with regard to whether it is pointing towards the TouchSensor node's geometry
or not. When the pointing device changes state from a position such that
its bearing does not intersect any of the TouchSensor node's geometry to
one in which it does intersect geometry, an <i>isOver</i> TRUE event is
generated. When the pointing device moves from a position such that its
bearing intersects geometry to one in which it no longer intersects the
geometry, or some other geometry is obstructing the TouchSensor node's geometry,
an <i>isOver</i> FALSE event is generated. These events are generated only
when the pointing device has moved and changed `over' state. Events are
not generated if the geometry itself is animating and moving underneath
the pointing device.</p>

<p>As the user moves the bearing over the TouchSensor node's geometry, the
point of intersection (if any) between the bearing and the geometry is determined.
Each movement of the pointing device, while <i>isOver</i> is TRUE, generates
<i>hitPoint_changed</i>, <i>hitNormal_changed</i> and <i>hitTexCoord_changed
</i>events. <i>hitPoint_changed</i> events contain the 3D point on the surface
of the underlying geometry, given in the TouchSensor node's coordinate system.
<i>hitNormal_changed</i> events contain the surface normal vector at the
<i>hitPoint</i>. <i>hitTexCoord_changed</i> events contain the texture coordinates
of that surface at the <i>hitPoint</i>. The values of <i>hitTexCoord_changed</i>
and <i>hitNormal_changed</i> events are computed as appropriate for the
associated shape.<br>
</p>

<p>If <i>isOver</i> is TRUE, the user may activate the pointing device to
cause the TouchSensor node to generate <i>isActive</i> events (e.g.,&nbsp;by
pressing the primary mouse button). When the TouchSensor node generates
an <i>isActive</i> TRUE event, it grabs all further motion events from the
pointing device until it is released and generates an <i>isActive</i> FALSE
event (other pointing-device sensors will not generate events during this
time). Motion of the pointing device while <i>isActive</i> is TRUE is termed
a &quot;drag.&quot; If a 2D pointing device is in use, <i>isActive</i> events
reflect the state of the primary button associated with the device (i.e.,&nbsp;<i>isActive</i>
is TRUE when the primary button is pressed and FALSE when it is released).
If a 3D pointing device is in use, <i>isActive</i> events will typically
reflect whether the pointing device is within (or in contact with) the TouchSensor
node's geometry.</p>

<p>The eventOut field <i>touchTime </i>is generated when all three of the
following conditions are true:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>The pointing device <u>was</u> pointing towards the geometry when it
  was <u>initially</u> <u>activated</u> (<i>isActive</i> is TRUE).
  <li>The pointing device <u>is</u> currently pointing towards the <u>geometry</u>
  (<i>isOver</i> is TRUE).
  <li>The pointing device is <u>deactivated</u> (<i>isActive</i> FALSE event
  is also generated).
</ol><!--/NOEDIT--></p>

<p>More information about this behaviour is described in <a HREF="concepts.html#4.6.7.3">4.6.7.3,
Pointing-device sensors</a>, <a HREF="concepts.html#4.6.7.4">4.6.7.4, Drag
sensors</a>, and <a HREF="concepts.html#4.6.7.5">4.6.7.5, Activating and
manipulating sensors</a>.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Transform"></a>6.52 Transform</h2>

<pre>
<b>Transform { </b>
  eventIn      MFNode      addChildren
  eventIn      MFNode      removeChildren
  exposedField SFVec3f     <b>center           0 0 0    </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField MFNode      <b>children         []</b>
  exposedField SFRotation  <b>rotation         0 0 1 0  </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec3f     <b>scale            1 1 1    </b>#&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFRotation  <b>scaleOrientation 0 0 1 0  </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec3f     <b>translation      0 0 0    </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f     <b>bboxCenter       0 0 0    </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFVec3f     <b>bboxSize         -1 -1 -1 </b>#&nbsp;(0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)&nbsp;or&nbsp;-1,-1,-1
<b>} </b></pre>

<p>The Transform node is a grouping node that defines a coordinate system
for its children that is relative to the coordinate systems of its ancestors.
See <a HREF="concepts.html#4.4.4">4.4.4, Transformation hierarchy</a>, and
<a HREF="concepts.html#4.4.5">4.4.5, Standard units and coordinate system</a>,
for a description of coordinate systems and transformations.</p>

<p><a HREF="concepts.html#4.6.5">4.6.5, Grouping and children nodes</a>,
provides a description of the <i>children</i>, <i>addChildren</i>, and <i>removeChildren</i>
fields and eventIns.</p>

<p>The <i>bboxCenter</i> and <i>bboxSize</i> fields specify a bounding box
that encloses the children of the Transform node. This is a hint that may
be used for optimization purposes. The results are undefined if the specified
bounding box is smaller than the actual bounding box of the children at
any time. A default <i>bboxSize</i> value, (-1,&nbsp;-1,&nbsp;-1), implies
that the bounding box is not specified and, if needed, shall be calculated
by the browser. The bounding box shall be large enough at all times to enclose
the union of the group's children's bounding boxes; it shall not include
any transformations performed by the group itself (i.e., the bounding box
is defined in the local coordinate system of the children). The results
are undefined if the specified bounding box is smaller than the true bounding
box of the group. A description of the <i>bboxCenter</i> and <i>bboxSize</i>
fields is provided in <a HREF="concepts.html#4.6.4">4.6.4, Bounding boxes</a>.</p>

<p>The <i>translation</i>, <i>rotation</i>, <i>scale</i>, <i>scaleOrientation</i>
and <i>center</i> fields define a geometric 3D transformation consisting
of (in order):</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>a (possibly) non-uniform scale about an arbitrary point;
  <li>a rotation about an arbitrary point and axis;
  <li>a translation.
</ol><!--/NOEDIT--></p>

<p>The <i>center</i> field specifies a translation offset from the origin
of the local coordinate system (0,0,0). The <i>rotation</i> field specifies
a rotation of the coordinate system. The <i>scale</i> field specifies a
non-uniform scale of the coordinate system. <i>scale</i> values shall be
greater than&nbsp;zero. The <i>scaleOrientation</i> specifies a rotation
of the coordinate system before the scale (to specify scales in arbitrary
orientations). The <i>scaleOrientation</i> applies only to the scale operation.
The <i>translation</i> field specifies a translation to the coordinate system.</p>

<p>Given a 3-dimensional point <b>P</b> and Transform node, <b>P</b> is
transformed into point <b>P'</b> in its parent's coordinate system by a
series of intermediate transformations. In matrix transformation notation,
where C (<i>center</i>), SR (<i>scaleOrientation</i>), T (<i>translation</i>),
R (<i>rotation</i>), and S (<i>scale</i>) are the equivalent transformation
matrices,</p>

<pre>
<b>    P'</b> = T × C × R × SR × S × -SR × -C × <b>P</b></pre>

<p>The following Transform node:</p>

<pre>
<b>Transform { </b>
<b>    center           C</b>
<b>    rotation         R</b>
<b>    scale            S</b>
<b>    scaleOrientation SR</b>
<b>    translation      T</b>
<b>    children         [...]</b>
<b>}</b></pre>

<p>is equivalent to the nested sequence of:</p>

<pre>
<b>Transform {</b>
<b>  translation T </b>
<b>  children Transform {</b>
<b>    translation C</b>
<b>    children Transform {</b>
<b>      rotation R</b>
<b>      children Transform {</b>
<b>        rotation SR </b>
<b>        children Transform {</b>
<b>          scale S </b>
<b>          children Transform {</b>
<b>            rotation -SR </b>
<b>            children Transform {</b>
<b>              translation -C</b>
<b>              children [...]</b>
<b>}}}}}}}</b></pre>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="Viewpoint"></a>6.53 Viewpoint</h2>

<pre>
<b>Viewpoint { </b>
  eventIn      SFBool     set_bind
  exposedField SFFloat    <b>fieldOfView    0.785398  </b>#&nbsp;(0,<img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool     <b>jump           TRUE</b>
  exposedField SFRotation <b>orientation    0 0 1 0   </b># [-1,1],(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFVec3f    <b>position       0 0 10    </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  field        SFString  <b> description    &quot;&quot;</b>
  eventOut     SFTime     bindTime
  eventOut     SFBool     isBound
<b>}</b></pre>

<p>The Viewpoint node defines a specific location in the local coordinate
system from which the user may view the scene. Viewpoint nodes are bindable
children nodes (see <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable&nbsp;children&nbsp;nodes</a>)
and thus there exists a Viewpoint node stack in the browser in which the
top-most Viewpoint node on the stack is the currently active Viewpoint node.
If a TRUE value is sent to the <i>set_bind</i> eventIn of a Viewpoint node,
it is moved to the top of the Viewpoint node stack and activated. When a
Viewpoint node is at the top of the stack, the user's view is conceptually
re-parented as a child of the Viewpoint node. All subsequent changes to
the Viewpoint node's coordinate system change the user's view (e.g.,&nbsp;changes
to any ancestor transformation nodes or to the Viewpoint node's <i>position</i>
or <i>orientation</i> fields). Sending a <i>set_bind </i>FALSE event removes
the Viewpoint node from the stack and produces <i>isBound </i>FALSE and
<i>bindTime</i> events. If the popped Viewpoint node is at the top of the
viewpoint stack, the user's view is re-parented to the next entry in the
stack. More details on binding stacks can be found in <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable&nbsp;children&nbsp;nodes</a>.
When a Viewpoint node is moved to the top of the stack, the existing top
of stack Viewpoint node sends an <i>isBound</i> FALSE event and is pushed
down the stack.</p>

<p>An author can automatically move the user's view through the world by
binding the user to a Viewpoint node and then animating either the Viewpoint
node or the transformations above it. Browsers shall allow the user view
to be navigated relative to the coordinate system defined by the Viewpoint
node (and the transformations above it) even if the Viewpoint node or its
ancestors' transformations are being animated.</p>

<p>The <i>bindTime</i> eventOut sends the time at which the Viewpoint node
is bound or unbound. This can happen:</p>

<p><!--NOEDIT--><ol START="1" TYPE="a">
  <li>during loading;
  <li>when a<i> set_bind </i>event is sent to the Viewpoint node;
  <li>when the browser binds to the Viewpoint node through its user interface
  described below.
</ol><!--/NOEDIT--></p>

<p>The <i>position</i> and <i>orientation</i> fields of the Viewpoint node
specify relative locations in the local coordinate system. <i>Position</i>
is relative to the coordinate system's origin (0,0,0), while <i>orientation</i>
specifies a rotation relative to the default orientation. In the default
position and orientation, the viewer is on the Z-axis looking down the -Z-axis
toward the origin with +X to the right and +Y straight up. Viewpoint nodes
are affected by the transformation hierarchy.</p>

<p>Navigation types (see <a HREF="nodesref.html#NavigationInfo">6.29, NavigationInfo</a>)
that require a definition of a down vector (e.g.,&nbsp;terrain following)
shall use the negative Y-axis of the coordinate system of the currently
bound Viewpoint node. Likewise, navigation types that require a definition
of an up vector shall use the positive Y-axis of the coordinate system of
the currently bound Viewpoint node. The <i>orientation</i> field of the
Viewpoint node does not affect the definition of the down or up vectors.
This allows the author to separate the viewing direction from the gravity
direction.</p>

<p>The <i>jump</i> field specifies whether the user's view &quot;jumps&quot;
to the position and orientation of a bound Viewpoint node or remains unchanged.
This jump is instantaneous and discontinuous in that no collisions are performed
and no ProximitySensor nodes are checked in between the starting and ending
jump points. If the user's position before the jump is inside a ProximitySensor
the <i>exitTime</i> of that sensor shall send the same timestamp as the
bind eventIn. Similarly, if the user's position after the jump is inside
a ProximitySensor the <i>enterTime</i> of that sensor shall send the same
timestamp as the bind eventIn. Regardless of the value of <i>jump</i> at
bind time, the relative viewing transformation between the user's view and
the current Viewpoint node shall be stored with the current Viewpoint node
for later use when <i>un-jumping</i> (i.e.,&nbsp;popping the Viewpoint node
binding stack from a Viewpoint node with <i>jump</i> TRUE<i>)</i>. The following
summarizes the bind stack rules (see <a HREF="concepts.html#4.6.10">4.6.10,&nbsp;Bindable&nbsp;children&nbsp;nodes</a>)
with additional rules regarding Viewpoint nodes (displayed in boldface type):</p>

<p><!--NOEDIT--><ol START="4" TYPE="a">
  <li>During read, the first encountered Viewpoint node is bound by pushing
  it to the top of the Viewpoint node stack. If a Viewpoint node name is specified in the URL
  that is being read, this named Viewpoint node is considered to be the first encountered Viewpoint node.
  Nodes contained within <a HREF="nodesref.html#Inline">Inline</a> nodes, within the strings passed to the Browser.createVrmlFromString()
  method, or within files passed to the Browser.createVrmlFromURL() method
  (see <a HREF="concepts.html#4.12.10">4.12.10, Browser script interface</a>) are
  not candidates for the first encountered Viewpoint node. The first node
  within a prototype instance is a valid candidate for the first encountered
  Viewpoint node. The first encountered Viewpoint node sends an <i>isBound
  </i>TRUE<i> </i>event.
  <li>When a <i>set_bind</i> TRUE event is received by a Viewpoint node,
  <ol START="1" TYPE="1">
    <li>If it is <u>not</u> on the top of the stack: <b>The relative transformation
    from the current top of stack Viewpoint node to the user's view is stored
    with the current top of stack Viewpoint node. </b>The current top of stack
    node sends an <i>isBound</i> FALSE event. The new node is <u>moved</u>
    to the top of the stack and becomes the currently bound Viewpoint node.
    The new Viewpoint node (top of stack) sends an <i>isBound </i>TRUE<i> </i>event.
    <b>If <i>jump</i> is TRUE for the new Viewpoint node, the user's view is
    instantaneously &quot;jumped&quot; to match the values in the <i>position</i>
    and <i>orientation</i> fields of the new Viewpoint node.</b>
    <li>If the node is already at the top of the stack, this event has no affect.
  </ol>
  <li>When a <i>set_bind</i> FALSE event is received by a Viewpoint node
  in the stack, it is removed from the stack. If it was on the top of the
  stack,
  <ol START="1" TYPE="1">
    <li>it sends an <i>isBound</i> FALSE event,
    <li>the next node in the stack becomes the currently bound Viewpoint node<i>
    </i>(i.e.,&nbsp;pop)<i> </i>and issues an<i> isBound </i>TRUE<i> </i>event,
    <li><b>if its <i>jump</i> field value is TRUE, the user's view is instantaneously
    &quot;jumped&quot; to the <i>position</i> and <i>orientation</i> of the
    next Viewpoint node in the stack <u>with</u> the stored relative transformation
    of this next Viewpoint node applied.</b>
  </ol>
  <li>If a <i>set_bind</i> FALSE event is received by a node not in the stack,
  the event is ignored and <i>isBound</i> events are not sent.
  <li>When a node replaces another node at the top of the stack, the <i>isBound</i>
  TRUE and FALSE events from the two nodes are sent simultaneously (i.e.,&nbsp;with
  identical timestamps).
  <li>If a bound node is deleted, it behaves as if it received a <i>set_bind
  </i>FALSE event (see c.).
</ol><!--/NOEDIT--></p>

<p>The <i>jump</i> field may change after a Viewpoint node is bound. The
rules described above still apply. If <i>jump</i> was TRUE when the Viewpoint
node is bound, but changed to FALSE before the <i>set_bind </i>FALSE is
sent, the Viewpoint node does not <i>un-jump</i> during unbind. If <i>jump</i>
was FALSE when the Viewpoint node is bound, but changed to TRUE before the
<i>set_bind </i>FALSE is sent, the Viewpoint node does perform the <i>un-jump</i>
during unbind.</p>

<p>Note that there are two other mechanisms that result in the binding of
a new Viewpoint:</p>

<p><!--NOEDIT--><ol START="10" TYPE="a">
  <li>An Anchor node's <i>url</i> field specifies a &quot;#ViewpointName&quot;.
  <li>A script invokes the <tt>loadURL()</tt> method and the URL argument
  specifies a &quot;#ViewpointName&quot;.
</ol><!--/NOEDIT--></p>

<p>Both of these mechanisms override the <i>jump</i> field value of the
specified Viewpoint node (#ViewpointName) and assume that <i>jump</i> is
TRUE when binding to the new Viewpoint. The behaviour of the viewer transition
to the newly bound Viewpoint depends on the currently bound NavigationInfo
node's <i>type</i> field value (see <a HREF="nodesref.html#NavigationInfo">6.29,&nbsp;NavigationInfo</a>).</p>

<p>The <i>fieldOfView</i> field specifies a preferred minimum viewing angle
from this viewpoint in radians. A small field of view roughly corresponds
to a telephoto lens; a large field of view roughly corresponds to a wide-angle
lens. The field of view shall be greater than zero and smaller than <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3">. The value of <i>fieldOfView</i>
represents the minimum viewing angle in any direction axis perpendicular
to the view. For example, a browser with a rectangular viewing projection
shall have the following relationship:</p>

<pre>
      display width    tan(FOV<sub>horizontal</sub>/2)
      -------------- = -----------------
      display height   tan(FOV<sub>vertical</sub>/2)</pre>

<p>where the smaller of display width or display height determines which
angle equals the <i>fieldOfView</i> (the larger angle is computed using
the relationship described above). The larger angle shall not exceed <img SRC="../Images/pi.gif" ALIGN="BOTTOM" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/pi.gif" WIDTH="12" HEIGHT="10" NATURALSIZEFLAG="3"> and may force the smaller angle
to be less than <i>fieldOfView</i> in order to sustain the aspect ratio.</p>

<p>The <i>description</i> field specifies a textual description of the Viewpoint
node. This may be used by browser-specific user interfaces. If a Viewpoint's
<i>description</i> field is empty it is recommended that the browser not
present this Viewpoint in its browser-specific user interface.</p>

<p>The URL syntax &quot;<tt>.../scene.wrl#ViewpointName</tt>&quot; specifies
the user's initial view when loading &quot;scene.wrl&quot; to be the first
Viewpoint node in the VRML file that appears as <b><tt>DEF&nbsp;ViewpointName&nbsp;Viewpoint&nbsp;{...}</tt></b>.
This overrides the first Viewpoint node in the VRML file as the initial
user view, and a <i>set_bind</i> TRUE message is sent to the Viewpoint node
named &quot;ViewpointName&quot;. If the Viewpoint node named &quot;ViewpointName&quot;
is not found, the browser shall use the first Viewpoint node in the VRML
file (i.e.&nbsp;the normal default behaviour). The URL syntax &quot;<tt>#ViewpointName</tt>&quot;
(i.e.&nbsp;no file name) specifies a viewpoint within the existing VRML
file. If this URL is loaded (e.g.&nbsp;Anchor node's <i>url</i> field or
<tt>loadURL()</tt> method is invoked by a Script node), the Viewpoint node
named &quot;ViewpointName&quot; is bound (a <i>set_bind</i> TRUE event is
sent to this Viewpoint node).</p>

<p>The results are undefined if a Viewpoint node is bound and is the child
of an LOD, Switch, or any node or prototype that disables its children.
If a Viewpoint node is bound that results in collision with geometry, the
browser shall perform its self-defined navigation adjustments as if the
user navigated to this point (see <a HREF="nodesref.html#Collision">6.8,&nbsp;Collision</a>).</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="VisibilitySensor"></a>6.54 VisibilitySensor</h2>

<pre>
<b>VisibilitySensor { </b>
  exposedField SFVec3f <b>center   0 0 0      </b>#&nbsp;(-<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  exposedField SFBool  <b>enabled  TRUE</b>
  exposedField SFVec3f <b>size     0 0 0      </b>#&nbsp;[0,<img SRC="../Images/infinity.gif" ALIGN="ABSMIDDLE" SGI_SRC="/usr/people/rikk/VRML/spec.DIS/Images/infinity.gif" WIDTH="21" HEIGHT="10" NATURALSIZEFLAG="3">)
  eventOut     SFTime  enterTime
  eventOut     SFTime  exitTime
  eventOut     SFBool  isActive
<b>}</b></pre>

<p>The VisibilitySensor node detects visibility changes of a rectangular
box as the user navigates the world. VisibilitySensor is typically used
to detect when the user can see a specific object or region in the scene
in order to activate or deactivate some behaviour or animation. The purpose
is often to attract the attention of the user or to improve performance.</p>

<p>The <i>enabled</i> field enables and disables the VisibilitySensor node.
If <i>enabled</i> is set to FALSE, the VisibilitySensor node does not send
events. If <i>enabled</i> is TRUE, the VisibilitySensor node detects changes
to the visibility status of the box specified and sends events through the
<i>isActive</i> eventOut. A TRUE event is output to <i>isActive</i> when
any portion of the box impacts the rendered view. A FALSE event is sent
when the box has no effect on the view. Browsers shall guarantee that, if
<i>isActive</i> is FALSE, the box has absolutely no effect on the rendered
view. Browsers may err liberally when <i>isActive</i> is TRUE. For example,
the box may affect the rendering.</p>

<p>The exposed fields <i>center</i> and <i>size</i> specify the object space
location of the box centre and the extents of the box (i.e.,&nbsp;width,
height, and depth). The VisibilitySensor node's box is affected by hierarchical
transformations of its parents. The components of the <i>size</i> field
shall be greater than or equal to zero.</p>

<p>The <i>enterTime</i> event is generated whenever the <i>isActive</i>
TRUE event is generated, and <i>exitTime</i> events are generated whenever
<i>isActive</i> FALSE events are generated. A VisibilitySensor read from
a VRML file shall generate <i>isActive </i>TRUE and <i>enterTime</i> events
if the sensor is enabled and the visibility box is visible. A VisibilitySensor
inserted into the transformation hierarchy shall generate <i>isActive </i>TRUE
and <i>enterTime</i> events if the sensor is enabled and the visibility
box is visible. A VisibilitySensor removed from the transformation hierarchy
shall generate <i>isActive </i>FALSE and <i>exitTime</i> events if the sensor
is enabled and the visibility box is visible.</p>

<p>Each VisibilitySensor node behaves independently of all other VisibilitySensor
nodes. Every enabled VisibilitySensor node that is affected by the user's
movement receives and sends events, possibly resulting in multiple VisibilitySensor
nodes receiving and sending events simultaneously. Unlike TouchSensor nodes,
there is no notion of a VisibilitySensor node lower in the scene graph &quot;grabbing&quot;
events. Multiply instanced VisibilitySensor nodes (i.e.,&nbsp;DEF/USE) use
the union of all the boxes defined by their instances. An instanced VisibilitySensor
node shall detect visibility changes for all instances of the box and send
events appropriately.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"></p>

<h2><img SRC="../Images/cube.gif" WIDTH="20" HEIGHT="19" ALT="+" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><a NAME="WorldInfo"></a>6.55 WorldInfo</h2>

<pre>
<b>WorldInfo { </b>
  field MFString <b>info  []</b>
  field SFString <b>title &quot;&quot;</b>
<b>}</b></pre>

<p>The WorldInfo node contains information about the world. This node is
strictly for documentation purposes and has no effect on the visual appearance
or behaviour of the world. The <i>title</i> field is intended to store the
name or title of the world so that browsers can present this to the user
(perhaps in the window border). Any other information about the world can
be stored in the <i>info</i> field, such as author information, copyright,
and usage instructions.</p>

<p><img SRC="../Images/vrmlbar.gif" WIDTH="470" HEIGHT="25" ALT="--- VRML separator bar ---" NATURALSIZEFLAG="0" ALIGN="BOTTOM"><br>
<font SIZE="-1"><a HREF="mailto:rikk@wasabisoft.com,gavin@wasabisoft.com,chris@marrin.com">Questions
or comments.</a></font><br>
<font SIZE="-1"><a HREF="../copyright.html">Copyright</a> &amp;COPY; 1997 The
VRML Consortium Incorporated.<br>
<tt>http://www.vrml.org/Specifications/VRML97/part1/nodesRef.html</tt></font>
</body>
</html>
